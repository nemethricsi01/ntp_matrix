

static const uint16_t Font13x16 [] = {
0b0001111111000000,
0b0011111111100000,
0b0111100011110000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b0111100011110000,
0b0011111111100000,
0b0001111111000000,

0b0000000011000000,
0b0000000111000000,
0b0000001111000000,
0b0000011111000000,
0b0000111111000000,
0b0001111111000000,
0b0011111111000000,
0b0000001111000000,
0b0000001111000000,
0b0000001111000000,
0b0000001111000000,
0b0000001111000000,
0b0000001111000000,
0b0000001111000000,
0b0000001111000000,
0b0000001111000000,

0b0001111111000000,
0b0011111111100000,
0b0111100011110000,
0b1111000001111000,
0b1111000001111000,
0b0000000001111000,
0b0000000011110000,
0b0000000111100000,
0b0000001111000000,
0b0000011110000000,
0b0000111100000000,
0b0001111000000000,
0b0011110000000000,
0b0111100000000000,
0b1111111111111111,
0b1111111111111111,

0b0001111111000000,
0b0011111111100000,
0b0111100011110000,
0b1111000001111000,
0b1111000001111000,
0b0000000001111000,
0b0000000011110000,
0b0000011111100000,
0b0000011111100000,
0b0000000011110000,
0b0000000001111000,
0b1111000001111000,
0b1111000001111000,
0b0111100011110000,
0b0011111111100000,
0b0001111111000000,

0b0000000011100000,
0b0000000111100000,
0b0000001111100000,
0b0000011111100000,
0b0000111111100000,
0b0001111111100000,
0b0011110111100000,
0b0111100111100000,
0b1111000111100000,
0b1111000111100000,
0b1111111111111000,
0b1111111111111000,
0b0000000111100000,
0b0000000111100000,
0b0000000111100000,
0b0000000111100000,

0b1111111111111000,
0b1111111111111000,
0b1111000000000000,
0b1111000000000000,
0b1111000000000000,
0b1111000000000000,
0b1111111111000000,
0b1111111111100000,
0b1111000011110000,
0b0000000001111000,
0b0000000001111000,
0b0000000001111000,
0b1111000001111000,
0b0111100011110000,
0b0011111111100000,
0b0001111111000000,

0b0001111111000000,
0b0011111111100000,
0b0111100011110000,
0b1111000001111000,
0b1111000000000000,
0b1111000000000000,
0b1111111111000000,
0b1111111111100000,
0b1111100011110000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b0111100011110000,
0b0011111111100000,
0b0001111111000000,

0b1111111111111000,
0b1111111111111000,
0b1111000001111000,
0b1111000001111000,
0b0000000011110000,
0b0000000011110000,
0b0000000111100000,
0b0000000111100000,
0b0000001111000000,
0b0000001111000000,
0b0000011110000000,
0b0000011110000000,
0b0000111100000000,
0b0000111100000000,
0b0001111000000000,
0b0001111000000000,

0b0001111111000000,
0b0011111111100000,
0b0111100011110000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b0111100011110000,
0b0011111111100000,
0b0111111111110000,
0b1111100011111000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b0111100011110000,
0b0011111111100000,
0b0001111111000000,

0b0001111111000000,
0b0011111111100000,
0b0111100011110000,
0b1111000001111000,
0b1111000001111000,
0b1111000001111000,
0b0111100011111000,
0b0011111111111000,
0b0001111111111000,
0b0000000001111000,
0b0000000001111000,
0b0000000001111000,
0b1111000001111000,
0b0111100011110000,
0b0011111111100000,
0b0001111111000000
};
static const uint32_t Font18x24[] = {
0b00000111111110000000000000000000,
0b00001111111111000000000000000000,
0b00111111111111110000000000000000,
0b01111110000111111000000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b01111110000111111000000000000000,
0b00111111111111110000000000000000,
0b00001111111111000000000000000000,
0b00000111111110000000000000000000,
								  
0b00000000001111000000000000000000,
0b00000000011111000000000000000000,
0b00000000111111000000000000000000,
0b00000001111111000000000000000000,
0b00000011111111000000000000000000,
0b00000111111111000000000000000000,
0b00001111111111000000000000000000,
0b00011111111111000000000000000000,
0b00111110111111000000000000000000,
0b01111100111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
								  
0b00000111111110000000000000000000,
0b00001111111111000000000000000000,
0b00111111111111110000000000000000,
0b01111110000111111000000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000111111000000000000000,
0b00000000001111110000000000000000,
0b00000000011111100000000000000000,
0b00000000111111000000000000000000,
0b00000001111110000000000000000000,
0b00000011111100000000000000000000,
0b00000111111000000000000000000000,
0b00001111110000000000000000000000,
0b00011111100000000000000000000000,
0b00111111000000000000000000000000,
0b01111110000000000000000000000000,
0b11111100000000000000000000000000,
0b11111111111111111100000000000000,
0b11111111111111111100000000000000,
0b11111111111111111100000000000000,
								  
0b00000111111110000000000000000000,
0b00001111111111000000000000000000,
0b00111111111111110000000000000000,
0b01111110000111111000000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000111111000000000000000,
0b00000000001111110000000000000000,
0b00000011111111100000000000000000,
0b00000011111111100000000000000000,
0b00000000001111110000000000000000,
0b00000000000111111000000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b01111110000111111000000000000000,
0b00111111111111110000000000000000,
0b00001111111111000000000000000000,
0b00000111111110000000000000000000,
								  
0b00000000000001100000000000000000,
0b00000000000011100000000000000000,
0b00000000000111100000000000000000,
0b00000000001111100000000000000000,
0b00000000011111100000000000000000,
0b00000000111111100000000000000000,
0b00000001111111100000000000000000,
0b00000011111111100000000000000000,
0b00000111111111100000000000000000,
0b00001111101111100000000000000000,
0b00011111001111100000000000000000,
0b00111110001111100000000000000000,
0b01111100001111100000000000000000,
0b11111100001111100000000000000000,
0b11111100001111100000000000000000,
0b11111111111111111100000000000000,
0b11111111111111111100000000000000,
0b11111111111111111100000000000000,
0b00000000011111100000000000000000,
0b00000000011111100000000000000000,
0b00000000011111100000000000000000,
0b00000000011111100000000000000000,
0b00000000011111100000000000000000,
0b00000000011111100000000000000000,
								  
0b11111111111111111100000000000000,
0b11111111111111111100000000000000,
0b11111111111111111100000000000000,
0b11111100000000000000000000000000,
0b11111100000000000000000000000000,
0b11111100000000000000000000000000,
0b11111100000000000000000000000000,
0b11111100000000000000000000000000,
0b11111100000000000000000000000000,
0b11111111111110000000000000000000,
0b11111111111111100000000000000000,
0b11111111111111110000000000000000,
0b11111000000111111000000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b01111110000111111000000000000000,
0b00111111111111110000000000000000,
0b00001111111111000000000000000000,
0b00000111111110000000000000000000,
								  
0b00000111111110000000000000000000,
0b00001111111111000000000000000000,
0b00111111111111110000000000000000,
0b01111110000111111000000000000000,
0b11111100000011111100000000000000,
0b11111100000000000000000000000000,
0b11111100000000000000000000000000,
0b11111100000000000000000000000000,
0b11111100000000000000000000000000,
0b11111100111000000000000000000000,
0b11111111111111000000000000000000,
0b11111111111111110000000000000000,
0b11111110000111111000000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b01111110000111111000000000000000,
0b00111111111111110000000000000000,
0b00001111111111000000000000000000,
0b00000111111110000000000000000000,
								  
0b11111111111111111100000000000000,
0b11111111111111111100000000000000,
0b11111111111111111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000111111000000000000000,
0b00000000000111111000000000000000,
0b00000000001111110000000000000000,
0b00000000001111110000000000000000,
0b00000000011111100000000000000000,
0b00000000011111100000000000000000,
0b00000000111111000000000000000000,
0b00000000111111000000000000000000,
0b00000001111110000000000000000000,
0b00000001111110000000000000000000,
0b00000011111100000000000000000000,
0b00000011111100000000000000000000,
0b00000111111000000000000000000000,
0b00000111111000000000000000000000,
0b00001111110000000000000000000000,
0b00001111110000000000000000000000,
0b00011111100000000000000000000000,
0b00011111100000000000000000000000,
								  
0b00000111111110000000000000000000,
0b00001111111111000000000000000000,
0b00111111111111110000000000000000,
0b01111110000111111000000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b01111110000111111000000000000000,
0b00111111111111110000000000000000,
0b00001111111111000000000000000000,
0b00111111111111110000000000000000,
0b01111110000111111000000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b01111110000111111000000000000000,
0b00111111111111110000000000000000,
0b00001111111111000000000000000000,
0b00000111111110000000000000000000,
								  
0b00000111111110000000000000000000,
0b00001111111111000000000000000000,
0b00111111111111110000000000000000,
0b01111110000111111000000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b11111100000011111100000000000000,
0b01111110000111111100000000000000,
0b00111111111111111100000000000000,
0b00001111111111111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b00000000000011111100000000000000,
0b11111100000011111100000000000000,
0b01111110000111111000000000000000,
0b00111111111111110000000000000000,
0b00001111111111000000000000000000,
0b00000111111110000000000000000000

};
static const uint16_t Font6x8 [] = {
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // sp
0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000, 0x2000, 0x0000,  // !
0x5000, 0x5000, 0x5000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // "
0x5000, 0x5000, 0xf800, 0x5000, 0xf800, 0x5000, 0x5000, 0x0000,  // #
0x2000, 0x7800, 0xa000, 0x7000, 0x2800, 0xf000, 0x2000, 0x0000,  // $
0xc000, 0xc800, 0x1000, 0x2000, 0x4000, 0x9800, 0x1800, 0x0000,  // %
0x4000, 0xa000, 0xa000, 0x4000, 0xa800, 0x9000, 0x6800, 0x0000,  // &
0x3000, 0x3000, 0x2000, 0x4000, 0x0000, 0x0000, 0x0000, 0x0000,  // '
0x1000, 0x2000, 0x4000, 0x4000, 0x4000, 0x2000, 0x1000, 0x0000,  // (
0x4000, 0x2000, 0x1000, 0x1000, 0x1000, 0x2000, 0x4000, 0x0000,  // )
0x2000, 0xa800, 0x7000, 0xf800, 0x7000, 0xa800, 0x2000, 0x0000,  // *
0x0000, 0x2000, 0x2000, 0xf800, 0x2000, 0x2000, 0x0000, 0x0000,  // +
0x0000, 0x0000, 0x0000, 0x0000, 0x3000, 0x3000, 0x2000, 0x0000,  // ,
0x0000, 0x0000, 0x0000, 0xf800, 0x0000, 0x0000, 0x0000, 0x0000,  // -
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3000, 0x3000, 0x0000,  // .
0x0000, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0000, 0x0000,  // /
0x7000, 0x8800, 0x9800, 0xa800, 0xc800, 0x8800, 0x7000, 0x0000,  // 0
0x2000, 0x6000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000,  // 1
0x7000, 0x8800, 0x0800, 0x7000, 0x8000, 0x8000, 0xf800, 0x0000,  // 2
0xf800, 0x0800, 0x1000, 0x3000, 0x0800, 0x8800, 0x7000, 0x0000,  // 3
0x1000, 0x3000, 0x5000, 0x9000, 0xf800, 0x1000, 0x1000, 0x0000,  // 4
0xf800, 0x8000, 0xf000, 0x0800, 0x0800, 0x8800, 0x7000, 0x0000,  // 5
0x3800, 0x4000, 0x8000, 0xf000, 0x8800, 0x8800, 0x7000, 0x0000,  // 6
0xf800, 0x0800, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0000,  // 7
0x7000, 0x8800, 0x8800, 0x7000, 0x8800, 0x8800, 0x7000, 0x0000,  // 8
0x7000, 0x8800, 0x8800, 0x7800, 0x0800, 0x1000, 0xe000, 0x0000,  // 9
0x0000, 0x0000, 0x2000, 0x0000, 0x2000, 0x0000, 0x0000, 0x0000,  // :
0x0000, 0x0000, 0x2000, 0x0000, 0x2000, 0x2000, 0x4000, 0x0000,  // ;
0x0800, 0x1000, 0x2000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0000,  // <
0x0000, 0x0000, 0xf800, 0x0000, 0xf800, 0x0000, 0x0000, 0x0000,  // =
0x4000, 0x2000, 0x1000, 0x0800, 0x1000, 0x2000, 0x4000, 0x0000,  // >
0x7000, 0x8800, 0x0800, 0x3000, 0x2000, 0x0000, 0x2000, 0x0000,  // ?
0x7000, 0x8800, 0xa800, 0xb800, 0xb000, 0x8000, 0x7800, 0x0000,  // @
0x2000, 0x5000, 0x8800, 0x8800, 0xf800, 0x8800, 0x8800, 0x0000,  // A
0xf000, 0x8800, 0x8800, 0xf000, 0x8800, 0x8800, 0xf000, 0x0000,  // B
0x7000, 0x8800, 0x8000, 0x8000, 0x8000, 0x8800, 0x7000, 0x0000,  // C
0xf000, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0xf000, 0x0000,  // D
0xf800, 0x8000, 0x8000, 0xf000, 0x8000, 0x8000, 0xf800, 0x0000,  // E
0xf800, 0x8000, 0x8000, 0xf000, 0x8000, 0x8000, 0x8000, 0x0000,  // F
0x7800, 0x8800, 0x8000, 0x8000, 0x9800, 0x8800, 0x7800, 0x0000,  // G
0x8800, 0x8800, 0x8800, 0xf800, 0x8800, 0x8800, 0x8800, 0x0000,  // H
0x7000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000,  // I
0x3800, 0x1000, 0x1000, 0x1000, 0x1000, 0x9000, 0x6000, 0x0000,  // J
0x8800, 0x9000, 0xa000, 0xc000, 0xa000, 0x9000, 0x8800, 0x0000,  // K
0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0xf800, 0x0000,  // L
0x8800, 0xd800, 0xa800, 0xa800, 0xa800, 0x8800, 0x8800, 0x0000,  // M
0x8800, 0x8800, 0xc800, 0xa800, 0x9800, 0x8800, 0x8800, 0x0000,  // N
0x7000, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000,  // O
0xf000, 0x8800, 0x8800, 0xf000, 0x8000, 0x8000, 0x8000, 0x0000,  // P
0x7000, 0x8800, 0x8800, 0x8800, 0xa800, 0x9000, 0x6800, 0x0000,  // Q
0xf000, 0x8800, 0x8800, 0xf000, 0xa000, 0x9000, 0x8800, 0x0000,  // R
0x7000, 0x8800, 0x8000, 0x7000, 0x0800, 0x8800, 0x7000, 0x0000,  // S
0xf800, 0xa800, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000,  // T
0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000,  // U
0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x5000, 0x2000, 0x0000,  // V
0x8800, 0x8800, 0x8800, 0xa800, 0xa800, 0xa800, 0x5000, 0x0000,  // W
0x8800, 0x8800, 0x5000, 0x2000, 0x5000, 0x8800, 0x8800, 0x0000,  // X
0x8800, 0x8800, 0x5000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000,  // Y
0xf800, 0x0800, 0x1000, 0x7000, 0x4000, 0x8000, 0xf800, 0x0000,  // Z
0x7800, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x7800, 0x0000,  // [
0x0000, 0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0000, 0x0000,  /* \ */
0x7800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x7800, 0x0000,  // ]
0x2000, 0x5000, 0x8800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // ^
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xf800, 0x0000,  // _
0x6000, 0x6000, 0x2000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000,  // `
0x0000, 0x0000, 0x6000, 0x1000, 0x7000, 0x9000, 0x7800, 0x0000,  // a
0x8000, 0x8000, 0xb000, 0xc800, 0x8800, 0xc800, 0xb000, 0x0000,  // b
0x0000, 0x0000, 0x7000, 0x8800, 0x8000, 0x8800, 0x7000, 0x0000,  // c
0x0800, 0x0800, 0x6800, 0x9800, 0x8800, 0x9800, 0x6800, 0x0000,  // d
0x0000, 0x0000, 0x7000, 0x8800, 0xf800, 0x8000, 0x7000, 0x0000,  // e
0x1000, 0x2800, 0x2000, 0x7000, 0x2000, 0x2000, 0x2000, 0x0000,  // f
0x0000, 0x0000, 0x7000, 0x9800, 0x9800, 0x6800, 0x0800, 0x0000,  // g
0x8000, 0x8000, 0xb000, 0xc800, 0x8800, 0x8800, 0x8800, 0x0000,  // h
0x2000, 0x0000, 0x6000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000,  // i
0x1000, 0x0000, 0x1000, 0x1000, 0x1000, 0x9000, 0x6000, 0x0000,  // j
0x8000, 0x8000, 0x9000, 0xa000, 0xc000, 0xa000, 0x9000, 0x0000,  // k
0x6000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000,  // l
0x0000, 0x0000, 0xd000, 0xa800, 0xa800, 0xa800, 0xa800, 0x0000,  // m
0x0000, 0x0000, 0xb000, 0xc800, 0x8800, 0x8800, 0x8800, 0x0000,  // n
0x0000, 0x0000, 0x7000, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000,  // o
0x0000, 0x0000, 0xb000, 0xc800, 0xc800, 0xb000, 0x8000, 0x0000,  // p
0x0000, 0x0000, 0x6800, 0x9800, 0x9800, 0x6800, 0x0800, 0x0000,  // q
0x0000, 0x0000, 0xb000, 0xc800, 0x8000, 0x8000, 0x8000, 0x0000,  // r
0x0000, 0x0000, 0x7800, 0x8000, 0x7000, 0x0800, 0xf000, 0x0000,  // s
0x2000, 0x2000, 0xf800, 0x2000, 0x2000, 0x2800, 0x1000, 0x0000,  // t
0x0000, 0x0000, 0x8800, 0x8800, 0x8800, 0x9800, 0x6800, 0x0000,  // u
0x0000, 0x0000, 0x8800, 0x8800, 0x8800, 0x5000, 0x2000, 0x0000,  // v
0x0000, 0x0000, 0x8800, 0x8800, 0xa800, 0xa800, 0x5000, 0x0000,  // w
0x0000, 0x0000, 0x8800, 0x5000, 0x2000, 0x5000, 0x8800, 0x0000,  // x
0x0000, 0x0000, 0x8800, 0x8800, 0x7800, 0x0800, 0x8800, 0x0000,  // y
0x0000, 0x0000, 0xf800, 0x1000, 0x2000, 0x4000, 0xf800, 0x0000,  // z
0x1000, 0x2000, 0x2000, 0x4000, 0x2000, 0x2000, 0x1000, 0x0000,  // {
0x2000, 0x2000, 0x2000, 0x0000, 0x2000, 0x2000, 0x2000, 0x0000,  // |
0x4000, 0x2000, 0x2000, 0x1000, 0x2000, 0x2000, 0x4000, 0x0000,  // }
0x4000, 0xa800, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // ~
};
static const uint16_t Font7x10 [] = {
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // sp
0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x1000, 0x0000, 0x0000,  // !
0x2800, 0x2800, 0x2800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // "
0x2400, 0x2400, 0x7C00, 0x2400, 0x4800, 0x7C00, 0x4800, 0x4800, 0x0000, 0x0000,  // #
0x3800, 0x5400, 0x5000, 0x3800, 0x1400, 0x5400, 0x5400, 0x3800, 0x1000, 0x0000,  // $
0x2000, 0x5400, 0x5800, 0x3000, 0x2800, 0x5400, 0x1400, 0x0800, 0x0000, 0x0000,  // %
0x1000, 0x2800, 0x2800, 0x1000, 0x3400, 0x4800, 0x4800, 0x3400, 0x0000, 0x0000,  // &
0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // '
0x0800, 0x1000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x1000, 0x0800,  // (
0x2000, 0x1000, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x1000, 0x2000,  // )
0x1000, 0x3800, 0x1000, 0x2800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // *
0x0000, 0x0000, 0x1000, 0x1000, 0x7C00, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000,  // +
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x1000, 0x1000,  // ,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3800, 0x0000, 0x0000, 0x0000, 0x0000,  // -
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000,  // .
0x0800, 0x0800, 0x1000, 0x1000, 0x1000, 0x1000, 0x2000, 0x2000, 0x0000, 0x0000,  // /
0x3800, 0x4400, 0x4400, 0x5400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // 0
0x1000, 0x3000, 0x5000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // 1
0x3800, 0x4400, 0x4400, 0x0400, 0x0800, 0x1000, 0x2000, 0x7C00, 0x0000, 0x0000,  // 2
0x3800, 0x4400, 0x0400, 0x1800, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000, 0x0000,  // 3
0x0800, 0x1800, 0x2800, 0x2800, 0x4800, 0x7C00, 0x0800, 0x0800, 0x0000, 0x0000,  // 4
0x7C00, 0x4000, 0x4000, 0x7800, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000, 0x0000,  // 5
0x3800, 0x4400, 0x4000, 0x7800, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // 6
0x7C00, 0x0400, 0x0800, 0x1000, 0x1000, 0x2000, 0x2000, 0x2000, 0x0000, 0x0000,  // 7
0x3800, 0x4400, 0x4400, 0x3800, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // 8
0x3800, 0x4400, 0x4400, 0x4400, 0x3C00, 0x0400, 0x4400, 0x3800, 0x0000, 0x0000,  // 9
0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000,  // :
0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x1000, 0x1000, 0x1000,  // ;
0x0000, 0x0000, 0x0C00, 0x3000, 0x4000, 0x3000, 0x0C00, 0x0000, 0x0000, 0x0000,  // <
0x0000, 0x0000, 0x0000, 0x7C00, 0x0000, 0x7C00, 0x0000, 0x0000, 0x0000, 0x0000,  // =
0x0000, 0x0000, 0x6000, 0x1800, 0x0400, 0x1800, 0x6000, 0x0000, 0x0000, 0x0000,  // >
0x3800, 0x4400, 0x0400, 0x0800, 0x1000, 0x1000, 0x0000, 0x1000, 0x0000, 0x0000,  // ?
0x3800, 0x4400, 0x4C00, 0x5400, 0x5C00, 0x4000, 0x4000, 0x3800, 0x0000, 0x0000,  // @
0x1000, 0x2800, 0x2800, 0x2800, 0x2800, 0x7C00, 0x4400, 0x4400, 0x0000, 0x0000,  // A
0x7800, 0x4400, 0x4400, 0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x0000, 0x0000,  // B
0x3800, 0x4400, 0x4000, 0x4000, 0x4000, 0x4000, 0x4400, 0x3800, 0x0000, 0x0000,  // C
0x7000, 0x4800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4800, 0x7000, 0x0000, 0x0000,  // D
0x7C00, 0x4000, 0x4000, 0x7C00, 0x4000, 0x4000, 0x4000, 0x7C00, 0x0000, 0x0000,  // E
0x7C00, 0x4000, 0x4000, 0x7800, 0x4000, 0x4000, 0x4000, 0x4000, 0x0000, 0x0000,  // F
0x3800, 0x4400, 0x4000, 0x4000, 0x5C00, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // G
0x4400, 0x4400, 0x4400, 0x7C00, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000, 0x0000,  // H
0x3800, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x3800, 0x0000, 0x0000,  // I
0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000, 0x0000,  // J
0x4400, 0x4800, 0x5000, 0x6000, 0x5000, 0x4800, 0x4800, 0x4400, 0x0000, 0x0000,  // K
0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x7C00, 0x0000, 0x0000,  // L
0x4400, 0x6C00, 0x6C00, 0x5400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000, 0x0000,  // M
0x4400, 0x6400, 0x6400, 0x5400, 0x5400, 0x4C00, 0x4C00, 0x4400, 0x0000, 0x0000,  // N
0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // O
0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x4000, 0x4000, 0x4000, 0x0000, 0x0000,  // P
0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x5400, 0x3800, 0x0400, 0x0000,  // Q
0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x4800, 0x4800, 0x4400, 0x0000, 0x0000,  // R
0x3800, 0x4400, 0x4000, 0x3000, 0x0800, 0x0400, 0x4400, 0x3800, 0x0000, 0x0000,  // S
0x7C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // T
0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // U
0x4400, 0x4400, 0x4400, 0x2800, 0x2800, 0x2800, 0x1000, 0x1000, 0x0000, 0x0000,  // V
0x4400, 0x4400, 0x5400, 0x5400, 0x5400, 0x6C00, 0x2800, 0x2800, 0x0000, 0x0000,  // W
0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x2800, 0x2800, 0x4400, 0x0000, 0x0000,  // X
0x4400, 0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // Y
0x7C00, 0x0400, 0x0800, 0x1000, 0x1000, 0x2000, 0x4000, 0x7C00, 0x0000, 0x0000,  // Z
0x1800, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1800,  // [
0x2000, 0x2000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0800, 0x0800, 0x0000, 0x0000,  /* \ */
0x3000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x3000,  // ]
0x1000, 0x2800, 0x2800, 0x4400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // ^
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFE00,  // _
0x2000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // `
0x0000, 0x0000, 0x3800, 0x4400, 0x3C00, 0x4400, 0x4C00, 0x3400, 0x0000, 0x0000,  // a
0x4000, 0x4000, 0x5800, 0x6400, 0x4400, 0x4400, 0x6400, 0x5800, 0x0000, 0x0000,  // b
0x0000, 0x0000, 0x3800, 0x4400, 0x4000, 0x4000, 0x4400, 0x3800, 0x0000, 0x0000,  // c
0x0400, 0x0400, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0000, 0x0000,  // d
0x0000, 0x0000, 0x3800, 0x4400, 0x7C00, 0x4000, 0x4400, 0x3800, 0x0000, 0x0000,  // e
0x0C00, 0x1000, 0x7C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // f
0x0000, 0x0000, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0400, 0x7800,  // g
0x4000, 0x4000, 0x5800, 0x6400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000, 0x0000,  // h
0x1000, 0x0000, 0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // i
0x1000, 0x0000, 0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0xE000,  // j
0x4000, 0x4000, 0x4800, 0x5000, 0x6000, 0x5000, 0x4800, 0x4400, 0x0000, 0x0000,  // k
0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // l
0x0000, 0x0000, 0x7800, 0x5400, 0x5400, 0x5400, 0x5400, 0x5400, 0x0000, 0x0000,  // m
0x0000, 0x0000, 0x5800, 0x6400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000, 0x0000,  // n
0x0000, 0x0000, 0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // o
0x0000, 0x0000, 0x5800, 0x6400, 0x4400, 0x4400, 0x6400, 0x5800, 0x4000, 0x4000,  // p
0x0000, 0x0000, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0400, 0x0400,  // q
0x0000, 0x0000, 0x5800, 0x6400, 0x4000, 0x4000, 0x4000, 0x4000, 0x0000, 0x0000,  // r
0x0000, 0x0000, 0x3800, 0x4400, 0x3000, 0x0800, 0x4400, 0x3800, 0x0000, 0x0000,  // s
0x2000, 0x2000, 0x7800, 0x2000, 0x2000, 0x2000, 0x2000, 0x1800, 0x0000, 0x0000,  // t
0x0000, 0x0000, 0x4400, 0x4400, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0000, 0x0000,  // u
0x0000, 0x0000, 0x4400, 0x4400, 0x2800, 0x2800, 0x2800, 0x1000, 0x0000, 0x0000,  // v
0x0000, 0x0000, 0x5400, 0x5400, 0x5400, 0x6C00, 0x2800, 0x2800, 0x0000, 0x0000,  // w
0x0000, 0x0000, 0x4400, 0x2800, 0x1000, 0x1000, 0x2800, 0x4400, 0x0000, 0x0000,  // x
0x0000, 0x0000, 0x4400, 0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x1000, 0x6000,  // y
0x0000, 0x0000, 0x7C00, 0x0800, 0x1000, 0x2000, 0x4000, 0x7C00, 0x0000, 0x0000,  // z
0x1800, 0x1000, 0x1000, 0x1000, 0x2000, 0x2000, 0x1000, 0x1000, 0x1000, 0x1800,  // {
0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,  // |
0x3000, 0x1000, 0x1000, 0x1000, 0x0800, 0x0800, 0x1000, 0x1000, 0x1000, 0x3000,  // }
0x0000, 0x0000, 0x0000, 0x7400, 0x4C00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // ~
};
uint8_t font7seg[] = {
0x77,//0
0x14,//1
0xB3,//2
0xB6,//3
0xd4,//4
0xe6,//5
0xe7,//6
0x34,//7
0xf7,//8
0xf6,//9
0x83,//c
0x97,//d
0xc5,//h
0x41,//i
0x85,//n
0xf1//p
};

#define DEBUG true      // change to false to stop Serial output if you use a display such as LED or LCD
#include <FS.h>                   //this needs to be first, or it all crashes and burns...
#include <WiFiManager.h> // https://github.com/tzapu/WiFiManager
#include <TM1637Display.h>//https://github.com/avishorp/TM1637/tree/master
#include <string.h>
#include <stdint.h>
#include <TimeLib.h>    // https://github.com/PaulStoffregen/Time
#include <Timezone.h>   // https://github.com/JChristensen/Timezone
#include <DS3232RTC.h>  // https://github.com/JChristensen/DS3232RTC
#include <Streaming.h>  // https://github.com/geneReeves/ArduinoStreaming
#include <SPI.h>
#include <WiFi.h>
#include <WiFiUdp.h>
 #include <SPIFFS.h>
#include <ArduinoJson.h> // https://github.com/bblanchon/ArduinoJson
#include <Adafruit_NeoPixel.h>

#define TRIGGER_PIN 0
#define CLK 16
#define DIO 15
#define PWMPIN 7
#define RTC_INTERRUPT_PIN 9 // interrupt on GPIO 12
#define LATCHPIN 14
#define OEPIN 3
#define VSPI_MISO   MISO
#define VSPI_MOSI   MOSI
#define VSPI_SCLK   SCK
#define VSPI_SS     SS

#define UDP_LISTEN_PORT 8888
#define VSPI FSPI

#define BLOCKSX     4
Adafruit_NeoPixel led(1, 48, NEO_GRB + NEO_KHZ800);
uint8_t sevenSegBuff[5];

char spiffs_SSID[30] = "GMPuc6";
char spiffs_PASSWORD[30] = "75000000";

char spiffs_DHCP[2] = "1";
char spiffs_IP_ADDR[30] = "192.168.1.123";
char spiffs_IP_GATE[30] = "192.168.1.1";
char spiffs_IP_MASK[30] = "255.255.255.0";
char spiffs_IP_ACCESS[30] = "192.168.4.10";
char spiffs_AP_TIMEOUT[4] = "10";
char spiffs_NTP_IP[30] = "192.168.1.100";
char spiffs_NTP_URL[40] = "time.windows.com";
char spiffs_NTP_DAYLIGHT[30] = "1";
char spiffs_NTP_TIMEZONE[30] = "CE";
char spiffs_NTP_GPSENABLE[30] = "0";
char spiffs_BRIGHTNESS_AUTOMANUAL[30] = "0";
char spiffs_BRIGHTNESS_VAL[30] = "32";
char spiffs_COLON_BLINK[30] = "1";
char spiffs_DISPLAY_SIZE[30] = "32";


#define MILLIS_MIN 2000UL // 2 seconds
#define MILLIS_MAX 4294967295UL - MILLIS_MIN  // value - 2000 (2 seconds)

const char* weekdays[8] = {"Err", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
const char* months[13] = {"Err", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

bool ntpFetchFlag = false, ntpSetFlag = false, timeSynced = false, ntpFailFlag = false;
uint32_t rtcSetDelay = 0;
uint8_t ntpFailCounter = 0;
bool connected = false;


WiFiManagerParameter custom_ipconfig_text                 ("<b><center>IP CONFIGURATION</center></b>");//////////////////////////////////////////
WiFiManagerParameter custom_dhcp                          ("dhcp", "DHCP settings:(1:on,0:off)", spiffs_DHCP, 40);
WiFiManagerParameter custom_ip_addr                       ("ip_addr", "Static ip address(only valid if dhcp = 0)", spiffs_IP_ADDR, 40);
WiFiManagerParameter custom_ip_gate                       ("ip_gate", "Static gateway address(only valid if dhcp = 0)", spiffs_IP_GATE, 40);
WiFiManagerParameter custom_ip_mask                       ("ip_mask", "Static subnet mask(only valid if dhcp = 0)", spiffs_IP_MASK, 40);
WiFiManagerParameter custom_ip_access                     ("ip_access", "Access point ip address", spiffs_IP_ACCESS, 40);
WiFiManagerParameter custom_ap_timeout                    ("ap_timeout", "Access point timeout x10sec (max 255)", spiffs_AP_TIMEOUT, 40);
WiFiManagerParameter custom_ntpconfig_text                ("<b><center>NTP CONFIGURATION</center></b>");//////////////////////////////////////////
WiFiManagerParameter custom_ntp_ip                        ("ntp_ip", "NTP ip server address", spiffs_NTP_IP, 40);
WiFiManagerParameter custom_ntp_url                       ("ntp_url", "NTP url(only valid if ip is set to 0)", spiffs_NTP_URL, 40);
WiFiManagerParameter custom_daylightsavings_helper        ("<p>daylight savings options:CEST CET CE</p>");//////////////////////////////////////////
WiFiManagerParameter custom_daylightsavings_helper2       ("<p>CEST: Central European Summer time CET: Central European Standard Time  CE: Automatic change</p>");//////////////////////////////////////////
WiFiManagerParameter custom_ntp_timezone                  ("ntp_timezone", "NTP timezone setting", spiffs_NTP_TIMEZONE, 40);
WiFiManagerParameter custom_ntp_gpsenable                 ("ntp_tgpsenable", "GPS enable:(1:on,0:off)", spiffs_NTP_GPSENABLE, 5);
WiFiManagerParameter custom_display_config_text           ("<b><center>DISPLAY CONFIGURATION</center></b>");////////////////////////////////////
WiFiManagerParameter custom_display_brightness_automanual ("display_brightness_automanual", "Display brightness setup(auto: 0/manua: l)", spiffs_BRIGHTNESS_AUTOMANUAL, 40);
WiFiManagerParameter custom_display_brightness_val        ("display_brightness_val", "Display brightness set(1-100%)", spiffs_BRIGHTNESS_VAL, 40);
WiFiManagerParameter custom_display_colon_blink           ("display_colon_blink", "Display colon(double dot) blink:(1:on,0:off)", spiffs_COLON_BLINK, 40);
WiFiManagerParameter custom_display_size                  ("display_size", "Display size (16,32,48,4d7s)", spiffs_DISPLAY_SIZE, 40);

bool shouldSaveConfig = false;
bool shouldSaveWifiConfig = false;

void saveConfigCallback () {
  Serial.println("Should save config");
  shouldSaveConfig = true;
}


uint8_t x = 48,y = 0;
uint16_t displayData[192];
char dispbuff[50];
uint8_t timerFlag;
uint8_t toggle;
unsigned int  timeout   = 120; // seconds to run for
unsigned int  startTime = millis();
bool portalRunning      = false;
bool startAP            = true; // start AP and webserver if true, else start only webserver
char ntpip[40] = {'0','0','0','0','0','0','0','0','0','0',
                  '0','0','0','0','0','0','0','0','0','0',
                  '0','0','0','0','0','0','0','0','0','0',
                  '0','0','0','0','0','0','0','0','0','0'};
int datacounter = 0;
int retryCounter;
// ISR variables
volatile uint32_t sysClock, ntpAlarmCounter; // the actual clock reference & fraction in millis
volatile bool outputTimestampEnable = false;  // used to trigger output of the current time
volatile bool halfSec = false;

int dispBrightness = 128;
int dispBrightnessPercent = 50;


WiFiManager wm;
TM1637Display display(CLK, DIO);
DS3232RTC RTC;
SPIClass * vspi = NULL;

WiFiUDP ntpClient;

boolean isIp(String str) {
  for (size_t i = 0; i < str.length(); i++) {
    int c = str.charAt(i);
    if (c != '.' && (c < '0' || c > '9')) {
      return false;
    }
  }
  return true;
}


void wifiSaveConfigCallback () {
  Serial.println("Should save wifi config");
  shouldSaveWifiConfig = true;
  if (shouldSaveWifiConfig) {
    Serial.println("saving  wifi config");
    wm.getWiFiSSID().toCharArray(spiffs_SSID,wm.getWiFiSSID().length()+1);
    wm.getWiFiPass().toCharArray(spiffs_PASSWORD,wm.getWiFiPass().length()+1);

    
    
    Serial.println(spiffs_SSID);
    Serial.println(spiffs_PASSWORD);
    DynamicJsonDocument json(1024);

    json["SSID"] = spiffs_SSID;
    json["PASSWORD"] = spiffs_PASSWORD;

    json["DHCP_ONOFF"] = spiffs_DHCP;
    json["STATIC_IP_ADD"] = spiffs_IP_ADDR;
    json["STATIC_DEF_GATE"] = spiffs_IP_GATE;
    json["STATIC_SUBNET"] = spiffs_IP_MASK;
    json["ACCESS_POINT_IP"] = spiffs_IP_ACCESS;
    json["ACCESS_POINT_TIMEOUT"] = spiffs_AP_TIMEOUT;
    json["NTP_ADD"] = spiffs_NTP_IP;
    json["NTP_URL"] = spiffs_NTP_URL;
    json["NTP_DAYLIGHTSAVINGS"] = spiffs_NTP_DAYLIGHT;
    json["NTP_TIMEZONE"] = spiffs_NTP_TIMEZONE;
    json["NTP_GPSENABLE"] = spiffs_NTP_GPSENABLE;
    json["BRIGHTNESS_AUTOMANUAL"] = spiffs_BRIGHTNESS_AUTOMANUAL;
    json["BRIGHTNESS_VAL"] = spiffs_BRIGHTNESS_VAL;
    json["DISPLAY_COLON_BLINK"] = spiffs_COLON_BLINK;
    json["DISPLAY_SIZE"] = spiffs_DISPLAY_SIZE;

    File configFile = SPIFFS.open("/config.json", "w");
    if (!configFile) {
      Serial.println("failed to open config file for writing");
    }
    serializeJson(json, Serial);
    serializeJson(json, configFile);
    configFile.close();
    //end save
    shouldSaveWifiConfig = false;
  }
}

/* TIMEZONE */
/*
   Pre-defined timezone definition examples. Use only one of these at a time or risk running
   out of memory on a small AVR e.g. ATmega328. Replace the example UK timezone definition
   with one of these. See the Timezone library documentation for further details.

  // US Eastern Time Zone (New York, Detroit)
  TimeChangeRule usEDT = {"EDT", Second, Sun, Mar, 2, -240};  // Eastern Daylight Time = UTC - 4 hours
  TimeChangeRule usEST = {"EST", First, Sun, Nov, 2, -300};   // Eastern Standard Time = UTC - 5 hours
  Timezone usET(usEDT, usEST);

  // US Central Time Zone (Chicago, Houston)
  TimeChangeRule usCDT = {"CDT", Second, dowSunday, Mar, 2, -300};
  TimeChangeRule usCST = {"CST", First, dowSunday, Nov, 2, -360};
  Timezone usCT(usCDT, usCST);

  // US Mountain Time Zone (Denver, Salt Lake City)
  TimeChangeRule usMDT = {"MDT", Second, dowSunday, Mar, 2, -360};
  TimeChangeRule usMST = {"MST", First, dowSunday, Nov, 2, -420};
  Timezone usMT(usMDT, usMST);

  // Arizona is US Mountain Time Zone but does not use DST
  Timezone usAZ(usMST, usMST);

  // US Pacific Time Zone (Las Vegas, Los Angeles)
  TimeChangeRule usPDT = {"PDT", Second, dowSunday, Mar, 2, -420};
  TimeChangeRule usPST = {"PST", First, dowSunday, Nov, 2, -480};
  Timezone usPT(usPDT, usPST);
*/
//Central European Time (Frankfurt, Paris)
TimeChangeRule CEST = {"CEST", Last, Sun, Mar, 2, 120};     //Central European Summer Time
TimeChangeRule CET = {"CET ", Last, Sun, Oct, 3, 60};       //Central European Standard Time
Timezone CE(CEST, CET);
Timezone CEst(CEST, CEST);
Timezone CEt(CET, CET);
/*
//United Kingdom (London, Belfast)
TimeChangeRule BST = {"BST", Last, Sun, Mar, 1, 60};        //British Summer Time
TimeChangeRule GMT = {"GMT", Last, Sun, Oct, 2, 0};         //Standard Time
Timezone UK(BST, GMT);
*/
TimeChangeRule *tcr;        //pointer to the time change rule, use to get the TZ abbrev

#define TIME_ZONE CE  // change to CE for European local time etc.

/*********************/
/* FUNCTIONS AND ISR */
/*********************/


//volatile uint32_t sysFraction;  // for future development
hw_timer_t *My_timer = NULL;
void IRAM_ATTR onTimer(){
timerFlag = 1;
}
void ICACHE_RAM_ATTR rtcIntISR(void);
// the RTC 1PPS signal calls this ISR
void ICACHE_RAM_ATTR rtcIntISR(void) {
  halfSec = digitalRead(RTC_INTERRUPT_PIN);
  outputTimestampEnable = true; // signals OK to print out the 
  if(!halfSec) {
    // This increments the sysClock and sets the outputTimestampEnable flag
    sysClock++; // the system timestamp is incremented every second by the RTC
    //sysFraction = millis(); // for future development
    ntpAlarmCounter++; // used to trigger NTP time fetches
  }
}// END OF rtcIntISR

// the NTP client calls this function to read the NTP packetBuffer time values
uint32_t readNtpBuffer(uint8_t * buff, uint8_t _start) {
  // NTP data is sent as Big Endian so we need to convert it for Arduino use.
  // Reads the 4 Bytes from the NTP buffer and returns temp as Little Endian
  uint32_t temp;
  uint8_t* tmp = reinterpret_cast<uint8_t*>(&temp);
  for (uint8_t x = 0; x < 4; x++) tmp[x ^ 3] = buff[_start + x];
  return temp;
}// END OF readNtpBuffer

/**************/
/* NTP CLIENT */
/*************/

// an array of NTP servers. The specific server is specified by the index number
// in the call to sendNTPrequest(uint8_t index)
const char *ntpServer[3] = {"time.windows.com", "0.uk.pool.ntp.org", "0.jp.pool.ntp.org"}; // the NTP servers for testing

#define NTP_TIMEOUT 500       // maximum time to wait for an NTP server response in milliseconds
#define NTP_ROUNDTRIP_MAX 200  // the maximinun NTP round-trip in milliseconds
#define NTP_FETCH_PERIOD 60   // how often to fetch NTP time in seconds
#define NTP_FAIL_COUNT 5     // the number of times to retry an NTP fetch before giving up
#define NTP_FAIL_RETRY  10     // time in seconds to wait before trying an NTP re-fetch
#define NTP_PACKET_SIZE 48    // the size of the NTP packet
#define NTP_70_YEARS 2208988800UL // seconds between 1900 (NTP) & 1970 (UNIX)
#define SVR_TIME_SECS 40      // buffer offset for NTP timestamp
#define SVR_TIME_FRAC 44      // buffer offset for NTP fraction
uint32_t ntpTime, ntpFraction, ntpRoundtrip;
uint8_t packetBuffer[NTP_PACKET_SIZE];

// send an NTP request to the time server at the given address (ntpServer[index])
uint32_t sendNTPrequest(uint8_t index)
{
#if DEBUG
  Serial << F("ntp_req") << endl;
#endif
  // we can send an empty packet with just the first byte header to the NTP server
  memset(&packetBuffer, 0, NTP_PACKET_SIZE);
  packetBuffer[0] = 0b11100011;
  // send the NTP packet to the server
  ntpClient.flush(); // discard any previously received packet data
  ntpFraction = 0;
  // send the packet and exit if error
  if (!ntpClient.beginPacket(ntpServer[index], 123)) return 1;
  ntpClient.write(packetBuffer, NTP_PACKET_SIZE);
  if (!ntpClient.endPacket()) return 2;
  // now wait for the response from the server
  ntpRoundtrip = millis();
  bool _timeOut = true;
  uint8_t packetSize;
  uint32_t timeOutTimer = millis();
  while ((millis() - timeOutTimer) < NTP_TIMEOUT && _timeOut)
  {
    delay(0); // for ESP8266 compatibility
    if (packetSize = ntpClient.parsePacket()) _timeOut = false;
  }
  ntpRoundtrip = millis() - ntpRoundtrip;
  if (_timeOut) return 3;
  if (packetSize != NTP_PACKET_SIZE) return 4;
  // we got a valid response packet so carry on and
  // extract the timestamp and fractional seconds. Convert NTP timestamp to UNIX
  while (ntpClient.available()) ntpClient.read(packetBuffer, 48);
  ntpTime = readNtpBuffer(packetBuffer, SVR_TIME_SECS) - NTP_70_YEARS;
  // the timestamp fractional seconds are picoseconds so convert to milliseconds
  // ntpFraction * 10 ^ 6 / 2 ^ 32 /1000 = milliseconds
  ntpFraction = (uint32_t)((readNtpBuffer(packetBuffer, SVR_TIME_FRAC) * pow(10, 6)) / pow(2 , 32)) / 1000UL;
  return 0;
}// END OF sendNTPrequest
void drawPixel(uint8_t x, uint8_t y, uint8_t color) 
{
  uint16_t xBlock;
  uint8_t yHighOrLow;
  uint16_t mask;
  uint16_t xPos;
  yHighOrLow = y % 2;  //if even then result is 0, 0 means the lower
  xBlock = x / 8;
  xPos = x % 8;
  int16_t yTemp;
  
  if( x > 31 )
  {
    if(x < 64)
    {
    xBlock += 12;
    }
    if(x > 63)
    {
      xBlock += 24;
    }
  }
  
  if( y > 7 )
  {
    if(y < 16)
    {
      y = y-4;
      xBlock += 40; //here this needs to be changed back to 24 if i want to use the 2x2 grid display(idk yet why 24)
    }
    if(y > 15)
    {
       y = y-8;
      xBlock += 80; //here this needs to be changed back to 24 if i want to use the 2x2 grid display(idk yet why 24)
    }
    
    
  }
  
  // Serial.print("x:");Serial.print(x);
  // Serial.print("y:");Serial.println(y);
  // Serial.print("yHighOrLow:");Serial.print(yHighOrLow);
  // Serial.print("ycalc:");Serial.println((y / 2));
  // Serial.print("xBlock:");Serial.print(xBlock);
  // Serial.print("xPos:");Serial.println(xPos);
  if (color)  //draw
  {
    if (yHighOrLow == 0) 
    {
      displayData[xBlock + ((y / 2)*4) ] |= 1 << xPos;
    } else 
    {
      displayData[xBlock + ((y / 2)*4)] |= 1 << (xPos + 8);
    }
  } else  //clear
  {
    if (yHighOrLow == 0) 
    {
      displayData[xBlock + ((y / 2)*4) ] &= ~(1 << xPos);
    } else 
    {
      displayData[xBlock + ((y / 2)*4)] &= ~(1 << (xPos + 8));
    }
  }
}
void sendDisplay(void)
{
  digitalWrite(OEPIN, 1);
  vspi->beginTransaction(SPISettings(10000000, LSBFIRST, SPI_MODE0));

  for(int i = 0;i<144;i++)
  {
    vspi->transfer16(displayData[i]);
  }
  vspi->endTransaction();
  digitalWrite(LATCHPIN, 1);
  digitalWrite(LATCHPIN, 0);
  digitalWrite(OEPIN, 0);
}
void sendSevenSeg ( void )
{
  vspi->beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));
  /*
  display is filled from left to right so in order to write to the left digit i have 
  to send out that last(before the dots because they are the last)
  */
  vspi->transfer(sevenSegBuff[3]);//rightmost digit
  vspi->transfer(sevenSegBuff[2]);//2nd from the right
  vspi->transfer(sevenSegBuff[1]);//3rd from the right
  vspi->transfer(sevenSegBuff[0]);//4th from the right
  vspi->transfer(sevenSegBuff[4]);//dots, from the top: 0b11100000, msb is the upper dot

  vspi->endTransaction();
  digitalWrite(LATCHPIN, LOW); 
  digitalWrite(LATCHPIN, HIGH);
  delay(1); 
  digitalWrite(LATCHPIN, LOW); 
}
char WriteChar(char ch, uint8_t x,uint8_t y,uint8_t color) {
    uint32_t i, b, j;
    
    // Check if character is valid
    if (ch < 32 || ch > 126)
        return 0;
    
    // Use the font to write
    for(i = 0; i < 10; i++) 
    {
        b = Font7x10[(ch - 32) * 10 + i];
        for(j = 0; j < 7; j++) 
        {
            if((b << j) & 0x8000)  
            {
                drawPixel(x+j, (y+9)-i,color);
            } else 
            {
                drawPixel(x+j, (y+9)-i,!color);
            }
        }
    }
    return ch;
}
char WriteChar6x8(char ch, uint8_t x,uint8_t y,uint8_t color) {
    uint32_t i, b, j;
    
    // Check if character is valid
    if (ch < 32 || ch > 126)
        return 0;
    
    // Use the font to write
    for(i = 0; i < 8; i++) 
    {
        b = Font6x8[(ch - 32) * 8 + i];
        for(j = 0; j < 6; j++) 
        {
            if((b << j) & 0x8000)  
            {
                drawPixel(x+j, (y+7)-i,color);
            } else 
            {
                drawPixel(x+j, (y+7)-i,!color);
            }
        }
    }
    return ch;
}
char WriteBigChar(char ch, uint8_t x,uint8_t y,uint8_t color) {
    uint32_t xt, yt, i, f, j;
    
    // Check if character is valid
    if (ch < 48 || ch > 57)
        return 0;
    
    // Use the font to write
    for(i = 0; i < 16; i++) 
    {
        f = Font13x16[ ( ch - 48 ) *16 + i];
        for(j = 0; j < 13; j++) 
        {
            if((f << j) & 0x8000)  
            {
                drawPixel(x+j, 15-i,1);
            } else 
            {
                drawPixel(x+j, 15-i,!1);
            }
        }
    }
    return ch;
}
char WriteBiggerChar(char ch, uint8_t x,uint8_t y,uint8_t color) {
    uint32_t xt, yt, i, f, j;
    
    // Check if character is valid
    if (ch < 48 || ch > 57)
        return 0;
    
    // Use the font to write
    for(i = 0; i < 24; i++) 
    {
        f = Font18x24[ ( ch - 48 ) *24 + i];
        for(j = 0; j < 18; j++) 
        {
            if((f << j) & 0x80000000)  
            {
                drawPixel(x+j, 23-i,1);
            } else 
            {
                drawPixel(x+j, 23-i,!1);
            }
        }
    }
    return ch;
}
void writeChar7Seg(char ch, uint8_t pos)
{
  if(pos > 4)
  {
    return;
  }
  sevenSegBuff[pos] = font7seg[ch-0x30];
  sendSevenSeg();
}
void dispTest ( void )
{
  for(int x = 0; x< 4; x++)
  {
    memset(sevenSegBuff, 0, sizeof(sevenSegBuff));
    writeChar7Seg('8', x);
    delay(500);
  }
  for(int i = 0;i<8;i++)
  {
  vspi->beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));
  vspi->transfer(1<<i);
  vspi->transfer(1<<i);
  vspi->transfer(1<<i);
  vspi->transfer(1<<i);
  vspi->transfer(1<<i);

  vspi->endTransaction();
  digitalWrite(LATCHPIN, LOW); 
  digitalWrite(LATCHPIN, HIGH);
  delay(1); 
  digitalWrite(LATCHPIN, LOW); 
  delay(500);
  }
}
void setBrightness(int percent)
{
  ledcWrite(4, map(percent,100,0,0,255));
}
void saveConfig (void)
{
Serial.println("saving config");
    strcpy(spiffs_DHCP,                   custom_dhcp.getValue());
    strcpy(spiffs_IP_ADDR,                custom_ip_addr.getValue());
    strcpy(spiffs_IP_GATE,                custom_ip_gate.getValue());
    strcpy(spiffs_IP_MASK,                custom_ip_mask.getValue());
    strcpy(spiffs_IP_ACCESS,              custom_ip_access.getValue());
    strcpy(spiffs_AP_TIMEOUT,             custom_ap_timeout.getValue());
    strcpy(spiffs_NTP_IP,                 custom_ntp_ip.getValue());
    strcpy(spiffs_NTP_URL,                custom_ntp_url.getValue());
    strcpy(spiffs_NTP_TIMEZONE,           custom_ntp_timezone.getValue());
    strcpy(spiffs_NTP_GPSENABLE,          custom_ntp_gpsenable.getValue());
    strcpy(spiffs_BRIGHTNESS_AUTOMANUAL,  custom_display_brightness_automanual.getValue());
    strcpy(spiffs_BRIGHTNESS_VAL,         custom_display_brightness_val.getValue());
    strcpy(spiffs_COLON_BLINK,            custom_display_colon_blink.getValue());
    strcpy(spiffs_DISPLAY_SIZE,           custom_display_size.getValue());
    DynamicJsonDocument json(1024);
    Serial.print("ip add is ip?");
    Serial.println( isIp( (String)spiffs_IP_ADDR ) );


    json["SSID"] = spiffs_SSID;
    json["PASSWORD"] = spiffs_PASSWORD;
    json["DHCP_ONOFF"] = spiffs_DHCP;
    json["STATIC_IP_ADD"] = spiffs_IP_ADDR;
    json["STATIC_DEF_GATE"] = spiffs_IP_GATE;
    json["STATIC_SUBNET"] = spiffs_IP_MASK;
    json["ACCESS_POINT_IP"] = spiffs_IP_ACCESS;
    json["ACCESS_POINT_TIMEOUT"] = spiffs_AP_TIMEOUT;
    json["NTP_ADD"] = spiffs_NTP_IP;
    json["NTP_URL"] = spiffs_NTP_URL;
    json["NTP_DAYLIGHTSAVINGS"] = spiffs_NTP_DAYLIGHT;
    json["NTP_TIMEZONE"] = spiffs_NTP_TIMEZONE;
    json["NTP_GPSENABLE"] = spiffs_NTP_GPSENABLE;
    json["BRIGHTNESS_AUTOMANUAL"] = spiffs_BRIGHTNESS_AUTOMANUAL;
    json["BRIGHTNESS_VAL"] = spiffs_BRIGHTNESS_VAL;
    json["DISPLAY_COLON_BLINK"] = spiffs_COLON_BLINK;
    json["DISPLAY_SIZE"] = spiffs_DISPLAY_SIZE;

    File configFile = SPIFFS.open("/config.json", "w");
    if (!configFile) {
      Serial.println("failed to open config file for writing");
    }
    serializeJson(json, Serial);
    serializeJson(json, configFile);
    configFile.close();
    //end save

}
/**********************************************************************************************************************************************************/
/* SETUP */
/*********/
void setup() {
  
  pinMode(17, INPUT);
  pinMode(18, INPUT);
  display.setBrightness(7,true);
  
  WiFi.disconnect();
  vspi = new SPIClass(VSPI);
  vspi->begin(VSPI_SCLK, VSPI_MISO, VSPI_MOSI, VSPI_SS); //SCLK, MISO, MOSI, SS
  pinMode(LATCHPIN, OUTPUT);
  pinMode(OEPIN, OUTPUT);
  memset(displayData,0,32);
  My_timer = timerBegin(0, 80, true);
  timerAttachInterrupt(My_timer, &onTimer, true);
  timerAlarmWrite(My_timer, 1000000, true);
  timerAlarmEnable(My_timer); //Just Enable
  ledcSetup(4, 5000, 8);
  ledcAttachPin(6, 4);
  ledcWrite(4, 250);
  
#if DEBUG
  Serial.begin(57600);
  Serial << F("A.N.T. Accurate Ntp Time (C) Phil Morris 2018 <www.lydiard.plus.com>") << endl;
#endif


  if (SPIFFS.begin()) {
    Serial.println("mounted file system");
    if (SPIFFS.exists("/config.json")) {
      //file exists, reading and loading
      Serial.println("reading config file");
      File configFile = SPIFFS.open("/config.json", "r");
      if (configFile) {
        Serial.println("opened config file");
        size_t size = configFile.size();
        Serial.print("opened config file size:");
        Serial.println(size);
        // Allocate a buffer to store contents of the file.
        std::unique_ptr<char[]> buf(new char[size]);

        configFile.readBytes(buf.get(), size);
        DynamicJsonDocument json(1024);
        auto deserializeError = deserializeJson(json, buf.get());
        serializeJson(json, Serial);
        if ( ! deserializeError ) {
          Serial.println("\nparsed json");

          strcpy(spiffs_SSID,                   json["SSID"]);
          strcpy(spiffs_PASSWORD,               json["PASSWORD"]);
          strcpy(spiffs_DHCP,                   json["DHCP_ONOFF"]);
          strcpy(spiffs_IP_ADDR,                json["STATIC_IP_ADD"]);
          strcpy(spiffs_IP_GATE,                json["STATIC_DEF_GATE"]);
          strcpy(spiffs_IP_MASK,                json["STATIC_SUBNET"]);
          strcpy(spiffs_IP_ACCESS,              json["ACCESS_POINT_IP"]);
          strcpy(spiffs_AP_TIMEOUT,             json["ACCESS_POINT_TIMEOUT"]);
          strcpy(spiffs_NTP_IP,                 json["NTP_ADD"]);
          strcpy(spiffs_NTP_URL,                json["NTP_URL"]);
          strcpy(spiffs_NTP_DAYLIGHT,           json["NTP_DAYLIGHTSAVINGS"]);
          strcpy(spiffs_NTP_TIMEZONE,           json["NTP_TIMEZONE"]);
          strcpy(spiffs_NTP_GPSENABLE,          json["NTP_GPSENABLE"]);
          strcpy(spiffs_BRIGHTNESS_AUTOMANUAL,  json["BRIGHTNESS_AUTOMANUAL"]);
          strcpy(spiffs_BRIGHTNESS_VAL,         json["BRIGHTNESS_VAL"]);
          strcpy(spiffs_COLON_BLINK,            json["DISPLAY_COLON_BLINK"]);
          strcpy(spiffs_DISPLAY_SIZE,           json["DISPLAY_SIZE"]);
          Serial.println(spiffs_SSID);
          Serial.println(spiffs_PASSWORD);
        } else {
          Serial.println("failed to load json config");
        }
      }
    }
  } else {
    Serial.println("failed to mount FS");
  }
  
  
  wm.addParameter(&custom_ipconfig_text);
  wm.addParameter(&custom_dhcp);
  wm.addParameter(&custom_ip_addr);
  wm.addParameter(&custom_ip_gate);
  wm.addParameter(&custom_ip_mask);
  wm.addParameter(&custom_ip_access);
  wm.addParameter(&custom_ap_timeout);
  wm.addParameter(&custom_ntpconfig_text);
  wm.addParameter(&custom_ntp_ip);
  wm.addParameter(&custom_ntp_url);
  wm.addParameter(&custom_daylightsavings_helper);
  wm.addParameter(&custom_daylightsavings_helper2);
  wm.addParameter(&custom_ntp_timezone);
  wm.addParameter(&custom_ntp_gpsenable);
  wm.addParameter(&custom_display_config_text);
  wm.addParameter(&custom_display_brightness_automanual);
  wm.addParameter(&custom_display_brightness_val);
  wm.addParameter(&custom_display_colon_blink);
  wm.addParameter(&custom_display_size);

  wm.setBreakAfterConfig(true);

  wm.setSaveConfigCallback(wifiSaveConfigCallback);
  wm.setSaveParamsCallback(saveConfigCallback);
  RTC.begin();
  RTC.squareWave(DS3232RTC::SQWAVE_1_HZ);   // 1 Hz square wave

  sysClock = RTC.get(); // synchronise the sysClock with the RTC for initial time setting
  ntpAlarmCounter = NTP_FETCH_PERIOD - 2;  // trigger an NTP fetch on first-run
 
  wm.setHostname("NARVAL_CLOCK1");
  if(spiffs_DHCP[0] == '1')
  {
  WiFi.mode(WIFI_STA);
  WiFi.begin(spiffs_SSID,spiffs_PASSWORD);
  }
  else if(spiffs_DHCP[0] == '0')
  {
    // Set your Static IP address
    IPAddress local_IP;
    local_IP.fromString(spiffs_IP_ADDR);
    // Set your Gateway IP address
    IPAddress gateway;
    gateway.fromString(spiffs_IP_GATE);

    IPAddress subnet;
    subnet.fromString(spiffs_IP_MASK);
    IPAddress primaryDNS(8, 8, 8, 8);   //optional
    IPAddress secondaryDNS(8, 8, 4, 4); //optional
  WiFi.config(local_IP, gateway, subnet, primaryDNS, secondaryDNS);
  WiFi.mode(WIFI_STA);
  WiFi.begin(spiffs_SSID,spiffs_PASSWORD);
  delay(2000);
  while( ( WiFi.status() != WL_CONNECTED ) && ( retryCounter < 5) )
  {
    delay(5000);
  }
  
  Serial << (F("IP address is ")) << WiFi.localIP() << endl;
  }

 

  ntpClient.begin(UDP_LISTEN_PORT);

  // set up the RTC interrupt. MUST BE A VALID EXTERNAL INTERRUPT!
  // the Arduino ESP8266 IDE can support digitalPinToInterrupt()
  // but, to be safe...

  attachInterrupt(RTC_INTERRUPT_PIN, rtcIntISR, CHANGE);

  // the RTC Interrupt output is open collector so set the pullup resistor on the interrupt pin
  pinMode(RTC_INTERRUPT_PIN, INPUT_PULLUP);
  
  led.setPixelColor(0, led.Color(0, 8, 0));
  led.show();  
}// END OF setup

/********/
/* LOOP */
/********/

void loop() {

   if (shouldSaveConfig) 
   {
    saveConfig();
        shouldSaveConfig = false;
   }
  
  
  if (WiFi.status() == WL_CONNECTED && !connected) 
  {
    
    Serial.println("WiFi connected");
    Serial.println("IP address: ");
    memset(displayData,0x00,144*2);
    sprintf(dispbuff,"%s",WiFi.localIP().toString());
    int x = 0;
    for(int i = 0;i < strlen(dispbuff);i++)
    {
      WriteChar6x8(dispbuff[i], x,2,1);
      Serial.println(dispbuff[i]);
      x = x+6;
    }
    
    sendDisplay();
    delay(5000);
    Serial.println(WiFi.localIP());
    wm.setConfigPortalBlocking(false);
    wm.startWebPortal();
    connected=true;
  }  
  wm.process(); // do processing

  // is configuration portal requested?
  if(digitalRead(TRIGGER_PIN) == LOW && (!portalRunning)) 
  {
    if(startAP)
    {
      Serial.println("Button Pressed, Starting Config Portal");

      
      wm.setConfigPortalBlocking(false);
      wm.startConfigPortal("NARVAL_CLOCK");
    } else 
    {
      Serial.println("Button Pressed, Starting Web Portal");
      wm.startWebPortal();
    }  
    startTime = millis();
  }

  // ntpAlarmCounter increments each second and sets the ntpFetchFlag
  // when the required time period has elapsed.
  if (!ntpFetchFlag && ntpAlarmCounter == NTP_FETCH_PERIOD) ntpFetchFlag = true;  // fetch the NTP time

  //fetch the NTP time if millis haven't rolled over.
  // The valid window is millis > 2000 and millis < 4294967295 - 2000 and we also check that the NTP
  // round-trip time is acceptable. A basic retry counter attempts to fetch the NTP time a number of times
  // before giving up until the next scheduled NTP fetch time. The LED's first digit decimal point is lit
  // if the NTP fetch fails completely. On an LCD display, the first digit becomes '*'
  if (ntpFetchFlag && millis() > MILLIS_MIN && millis() < MILLIS_MAX) {
    // fetch the NTP timestamp from the indexed NTP server, returns 0 if successful
    // The index allows you to choose an NTP server from the server names array easily
    uint8_t result = sendNTPrequest(0);
    if (!result && ntpRoundtrip <= NTP_ROUNDTRIP_MAX) {
      // calculate the delay before updating the RTC and sysClock
      rtcSetDelay = (uint32_t)(millis() + (1000UL - ntpFraction)) + (ntpRoundtrip >> 1);
      ntpSetFlag = true;    // sync can take place
      ntpFailFlag = false;  // clear the ntpFailFlag
      ntpAlarmCounter = 0;  // clear the ntpAlarmCounter
      ntpTime++; // add 1 second as we're setting the sysClock 1 second late
    }
    else {
      // the NTP request returned an error status
#if DEBUG
      switch (result) {
        case 1:
          Serial << F("NTP beginPacket Failure!") << endl;
          break;
        case 2:
          Serial << F("NTP Client endPacket Failure!") << endl;
          break;
        case 3:
          Serial << F("NTP Timeout Error!") << endl;
          break;
        case 4:
          Serial << F("NTP Packet Size Error!") << endl;
          break;
        default:
          Serial << F("NTP Round-tript too long, aborting!") << endl;
      }
#endif
      // the NTP fetch has failed, so start counting the failures
      if (ntpFailCounter++ == NTP_FAIL_COUNT) {
        // total NTP fetch failure
        ntpAlarmCounter = 0;  // reset the ntpAlarmCounter
        ntpFailCounter = 0;   // reset the ntpFailCounter
        ntpFailFlag = true;   // set the ntpFailFlag
#if DEBUG
        Serial << F("Total NTP Fetch Failure!") << endl;
#endif
      }
      else ntpAlarmCounter -= NTP_FAIL_RETRY; // try an NTP fetch again in NTP_FAIL_RETRY seconds
    }
    ntpFetchFlag = false; // clear the fetch Alarm flag
  }

  // sync everything when rtcSetDelay has expired
  if (ntpSetFlag && millis() >= rtcSetDelay) {
    RTC.set(ntpTime); // set the RTC
    sysClock = ntpTime; // set sysClock
    ntpSetFlag = false; // clear the sync flag
    timeSynced = true;  // time DEBUG printout includes NTP timing details
    rtcSetDelay = 0;
  }

  // print out the sysClock timestamp
  if (outputTimestampEnable) {
    outputTimestampEnable = false;  // clear the trigger flag
    char buff[32];
    tmElements_t tm;
    // make the current local time using the Timezone library
    if( ( spiffs_NTP_TIMEZONE[0] == 'C' ) && ( spiffs_NTP_TIMEZONE[1] == 'E' ) && ( spiffs_NTP_TIMEZONE[2] == NULL ) )
    {
      breakTime(CE.toLocal(sysClock, &tcr), tm);
    }
    else if( ( spiffs_NTP_TIMEZONE[0] == 'C' ) && ( spiffs_NTP_TIMEZONE[1] == 'E' ) && ( spiffs_NTP_TIMEZONE[2] == 'T' )  && ( spiffs_NTP_TIMEZONE[3] == NULL ) )
    {
      breakTime(CEt.toLocal(sysClock, &tcr), tm);
    }
    else if( ( spiffs_NTP_TIMEZONE[0] == 'C' ) && ( spiffs_NTP_TIMEZONE[1] == 'E' ) && ( spiffs_NTP_TIMEZONE[2] == 'S' )  && ( spiffs_NTP_TIMEZONE[3] == 'T' ) && ( spiffs_NTP_TIMEZONE[4] == NULL ) )
    {
      breakTime(CEst.toLocal(sysClock, &tcr), tm);
    }
    sprintf(buff, "%02u:%02u:%02u %s  %02u-%s-20%02u", tm.Hour, tm.Minute, tm.Second, weekdays[tm.Wday], tm.Day, months[tm.Month], tm.Year - 30);
    int num;
    num = tm.Minute*100;
    num+= tm.Second;
    int analogVal = map(analogRead(8),0,4096,0,255);
    if(spiffs_BRIGHTNESS_AUTOMANUAL[0] == '1')
    {
      String brightnessval = String(spiffs_BRIGHTNESS_VAL);
      setBrightness(brightnessval.toInt());
    }
    if(spiffs_BRIGHTNESS_AUTOMANUAL[0] == '0')
    {
    
    setBrightness(map(analogVal,255,30,10,100));
    }
    
    
    display.showNumberDecEx(analogVal,0,false,4,0);
    if(halfSec)
    {
      if(spiffs_COLON_BLINK[0] == '1')
      {
        //display.showNumberDecEx(num,0b01000000,false,4,0);
      }
      else
      {
        //display.showNumberDecEx(num,0b01000000,false,4,0);
      }
      
      memset(displayData,0x00,144*2);

      // WriteChar((tm.Hour/10)+0x30,0,0, 1);
      // WriteChar((tm.Hour%10)+0x30,7,0, 1);
      // WriteChar(':',14,0, 1);
      // WriteChar((tm.Minute/10)+0x30,21,0, 1);
      // WriteChar((tm.Minute%10)+0x30,28,0, 1);
      // WriteChar(':',35,0, 1);
      // WriteChar((tm.Second/10)+0x30,42,0, 1);
      // WriteChar((tm.Second%10)+0x30,49,0, 1);
      /*WriteBiggerChar((tm.Minute/10)+0x30,0,0,1);
      WriteBiggerChar((tm.Minute%10)+0x30,16,0,1);
      drawPixel(31, 11, 1);
      drawPixel(31, 10, 1);
      drawPixel(32, 11, 1);
      drawPixel(32, 10, 1);

      drawPixel(31, 5, 1);
      drawPixel(31, 4, 1);
      drawPixel(32, 5, 1);
      drawPixel(32, 4, 1);
      WriteBiggerChar((tm.Second/10)+0x30,35,0,1);
      WriteBiggerChar((tm.Second%10)+0x30,51,0,1);
      //2x2 display
      */
      // WriteBiggerChar((tm.Minute/10)+0x30,0,0,1);
      // WriteBiggerChar((tm.Minute%10)+0x30,23,0,1);
      // for(int y = 15; y <18;y++)
      //  {
      //   for(int x = 45; x<51;x++)
      //   {
      //     drawPixel(x, y, 1);
      //   }
      //  }
      //  for(int y = 6; y <9;y++)
      //  {
      //   for(int x = 45; x<51;x++)
      //   {
      //     drawPixel(x, y, 1);
      //   }
      //  }
      // WriteBiggerChar((tm.Second/10)+0x30,55,0,1);
      // WriteBiggerChar((tm.Second%10)+0x30,78,0,1);
        //3*3 display
        writeChar7Seg((tm.Minute/10)+0x30, 0);
        writeChar7Seg((tm.Minute%10)+0x30, 1);
        writeChar7Seg((tm.Second/10)+0x30, 2);
        writeChar7Seg((tm.Second%10)+0x30, 3);





      // uint32_t temp = 0x24242424;
      // uint32_t temp2 = 0x24242424;
      // for(int i = 0;i<32;i++)
      // {
      //   if( ( temp >> i ) & 1 )
      //   {
      //     drawPixel(i,0,1);
      //   }
        
      // }
      // for(int i = 32;i<64;i++)
      // {
      //   if( ( temp2 >> i ) & 1 )
      //   {
      //     drawPixel(i,0,1);
      //   }
        
      // }
      //sendDisplay();
      
    }
    else
    {
     //display.showNumberDecEx(num,0b01000000,false,4,0);
      memset(displayData,0x00,144*2);

      // WriteChar((tm.Hour/10)+0x30,0,0, 1);
      // WriteChar((tm.Hour%10)+0x30,7,0, 1);
      // WriteChar(':',14,0, 1);
      // WriteChar((tm.Minute/10)+0x30,21,0, 1);
      // WriteChar((tm.Minute%10)+0x30,28,0, 1);
      // WriteChar(':',35,0, 1);
      // WriteChar((tm.Second/10)+0x30,42,0, 1);
      // WriteChar((tm.Second%10)+0x30,49,0, 1);

      /*WriteBiggerChar((tm.Minute/10)+0x30,0,0,1);
      WriteBiggerChar((tm.Minute%10)+0x30,16,0,1);
      drawPixel(31, 11, 1);
      drawPixel(31, 10, 1);
      drawPixel(32, 11, 1);
      drawPixel(32, 10, 1);

      drawPixel(31, 5, 1);
      drawPixel(31, 4, 1);
      drawPixel(32, 5, 1);
      drawPixel(32, 4, 1);
      WriteBiggerChar((tm.Second/10)+0x30,35,0,1);
      WriteBiggerChar((tm.Second%10)+0x30,51,0,1);
      //2x2 display
      */
      // WriteBiggerChar((tm.Minute/10)+0x30,0,0,1);
      // WriteBiggerChar((tm.Minute%10)+0x30,23,0,1);


      // WriteBiggerChar((tm.Second/10)+0x30,55,0,1);
      // WriteBiggerChar((tm.Second%10)+0x30,78,0,1);
      //3x3 display


        writeChar7Seg((tm.Minute/10)+0x30, 0);
        writeChar7Seg((tm.Minute%10)+0x30, 1);
        writeChar7Seg((tm.Second/10)+0x30, 2);
        writeChar7Seg((tm.Second%10)+0x30, 3);


      // uint32_t temp = 0x24242424;
      // uint32_t temp2 = 0x24242424;
      // for(int i = 0;i<32;i++)
      // {
      //   if( ( temp >> i ) & 1 )
      //   {
      //     drawPixel(i,0,1);
      //   }
        
      // }
      // for(int i = 32;i<64;i++)
      // {
      //   if( ( temp2 >> i ) & 1 )
      //   {
      //     drawPixel(i,0,1);
      //   }
        
      // }
      //sendDisplay();
      if(spiffs_COLON_BLINK[0] == '1')
      {
        //display.showNumberDecEx(num,0,false,4,0);
      }
      else
      {
        //display.showNumberDecEx(num,0b01000000,false,4,0);
      }
      
    }
    

#if DEBUG
    Serial.println(buff);
#endif
    
    timeSynced = false;
  }
  if(timerFlag)
    {
      if(toggle)
      {
        //memset(displayData,0x00,128);
        // x++;
        // if(x >63)
        // {
        //   x = 0;
        //   y++;
        //   if(y >15)
        //   {
        //     y = 0;
        //   }
        // }
        // drawPixel(x, y, 1);
        // WriteChar(x,10,0, 1);
        // x++;
        // if(x >91)
        // {
        //   x = 48;
        // }
          
      // sendDisplay();
        toggle = 0;
      }
      else
      {
      //   memset(displayData,0x00,128);
      // sendDisplay();
        toggle = 1;
      }
      timerFlag = 0;
    }
}// END OF loop
