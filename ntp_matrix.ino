

static const uint16_t Font13x16[] = {
  0b0001111111000000,
  0b0011111111100000,
  0b0111100011110000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b0111100011110000,
  0b0011111111100000,
  0b0001111111000000,

  0b0000000011000000,
  0b0000000111000000,
  0b0000001111000000,
  0b0000011111000000,
  0b0000111111000000,
  0b0001111111000000,
  0b0011111111000000,
  0b0000001111000000,
  0b0000001111000000,
  0b0000001111000000,
  0b0000001111000000,
  0b0000001111000000,
  0b0000001111000000,
  0b0000001111000000,
  0b0000001111000000,
  0b0000001111000000,

  0b0001111111000000,
  0b0011111111100000,
  0b0111100011110000,
  0b1111000001111000,
  0b1111000001111000,
  0b0000000001111000,
  0b0000000011110000,
  0b0000000111100000,
  0b0000001111000000,
  0b0000011110000000,
  0b0000111100000000,
  0b0001111000000000,
  0b0011110000000000,
  0b0111100000000000,
  0b1111111111111111,
  0b1111111111111111,

  0b0001111111000000,
  0b0011111111100000,
  0b0111100011110000,
  0b1111000001111000,
  0b1111000001111000,
  0b0000000001111000,
  0b0000000011110000,
  0b0000011111100000,
  0b0000011111100000,
  0b0000000011110000,
  0b0000000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b0111100011110000,
  0b0011111111100000,
  0b0001111111000000,

  0b0000000011100000,
  0b0000000111100000,
  0b0000001111100000,
  0b0000011111100000,
  0b0000111111100000,
  0b0001111111100000,
  0b0011110111100000,
  0b0111100111100000,
  0b1111000111100000,
  0b1111000111100000,
  0b1111111111111000,
  0b1111111111111000,
  0b0000000111100000,
  0b0000000111100000,
  0b0000000111100000,
  0b0000000111100000,

  0b1111111111111000,
  0b1111111111111000,
  0b1111000000000000,
  0b1111000000000000,
  0b1111000000000000,
  0b1111000000000000,
  0b1111111111000000,
  0b1111111111100000,
  0b1111000011110000,
  0b0000000001111000,
  0b0000000001111000,
  0b0000000001111000,
  0b1111000001111000,
  0b0111100011110000,
  0b0011111111100000,
  0b0001111111000000,

  0b0001111111000000,
  0b0011111111100000,
  0b0111100011110000,
  0b1111000001111000,
  0b1111000000000000,
  0b1111000000000000,
  0b1111111111000000,
  0b1111111111100000,
  0b1111100011110000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b0111100011110000,
  0b0011111111100000,
  0b0001111111000000,

  0b1111111111111000,
  0b1111111111111000,
  0b1111000001111000,
  0b1111000001111000,
  0b0000000011110000,
  0b0000000011110000,
  0b0000000111100000,
  0b0000000111100000,
  0b0000001111000000,
  0b0000001111000000,
  0b0000011110000000,
  0b0000011110000000,
  0b0000111100000000,
  0b0000111100000000,
  0b0001111000000000,
  0b0001111000000000,

  0b0001111111000000,
  0b0011111111100000,
  0b0111100011110000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b0111100011110000,
  0b0011111111100000,
  0b0111111111110000,
  0b1111100011111000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b0111100011110000,
  0b0011111111100000,
  0b0001111111000000,

  0b0001111111000000,
  0b0011111111100000,
  0b0111100011110000,
  0b1111000001111000,
  0b1111000001111000,
  0b1111000001111000,
  0b0111100011111000,
  0b0011111111111000,
  0b0001111111111000,
  0b0000000001111000,
  0b0000000001111000,
  0b0000000001111000,
  0b1111000001111000,
  0b0111100011110000,
  0b0011111111100000,
  0b0001111111000000
};
static const uint32_t Font18x24[] = {
  0b00000111111110000000000000000000,
  0b00001111111111000000000000000000,
  0b00111111111111110000000000000000,
  0b01111110000111111000000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b01111110000111111000000000000000,
  0b00111111111111110000000000000000,
  0b00001111111111000000000000000000,
  0b00000111111110000000000000000000,

  0b00000000001111000000000000000000,
  0b00000000011111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000001111111000000000000000000,
  0b00000011111111000000000000000000,
  0b00000111111111000000000000000000,
  0b00001111111111000000000000000000,
  0b00011111111111000000000000000000,
  0b00111110111111000000000000000000,
  0b01111100111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,

  0b00000111111110000000000000000000,
  0b00001111111111000000000000000000,
  0b00111111111111110000000000000000,
  0b01111110000111111000000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000111111000000000000000,
  0b00000000001111110000000000000000,
  0b00000000011111100000000000000000,
  0b00000000111111000000000000000000,
  0b00000001111110000000000000000000,
  0b00000011111100000000000000000000,
  0b00000111111000000000000000000000,
  0b00001111110000000000000000000000,
  0b00011111100000000000000000000000,
  0b00111111000000000000000000000000,
  0b01111110000000000000000000000000,
  0b11111100000000000000000000000000,
  0b11111111111111111100000000000000,
  0b11111111111111111100000000000000,
  0b11111111111111111100000000000000,

  0b00000111111110000000000000000000,
  0b00001111111111000000000000000000,
  0b00111111111111110000000000000000,
  0b01111110000111111000000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000111111000000000000000,
  0b00000000001111110000000000000000,
  0b00000011111111100000000000000000,
  0b00000011111111100000000000000000,
  0b00000000001111110000000000000000,
  0b00000000000111111000000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b01111110000111111000000000000000,
  0b00111111111111110000000000000000,
  0b00001111111111000000000000000000,
  0b00000111111110000000000000000000,

  0b00000000000001100000000000000000,
  0b00000000000011100000000000000000,
  0b00000000000111100000000000000000,
  0b00000000001111100000000000000000,
  0b00000000011111100000000000000000,
  0b00000000111111100000000000000000,
  0b00000001111111100000000000000000,
  0b00000011111111100000000000000000,
  0b00000111111111100000000000000000,
  0b00001111101111100000000000000000,
  0b00011111001111100000000000000000,
  0b00111110001111100000000000000000,
  0b01111100001111100000000000000000,
  0b11111100001111100000000000000000,
  0b11111100001111100000000000000000,
  0b11111111111111111100000000000000,
  0b11111111111111111100000000000000,
  0b11111111111111111100000000000000,
  0b00000000011111100000000000000000,
  0b00000000011111100000000000000000,
  0b00000000011111100000000000000000,
  0b00000000011111100000000000000000,
  0b00000000011111100000000000000000,
  0b00000000011111100000000000000000,

  0b11111111111111111100000000000000,
  0b11111111111111111100000000000000,
  0b11111111111111111100000000000000,
  0b11111100000000000000000000000000,
  0b11111100000000000000000000000000,
  0b11111100000000000000000000000000,
  0b11111100000000000000000000000000,
  0b11111100000000000000000000000000,
  0b11111100000000000000000000000000,
  0b11111111111110000000000000000000,
  0b11111111111111100000000000000000,
  0b11111111111111110000000000000000,
  0b11111000000111111000000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b01111110000111111000000000000000,
  0b00111111111111110000000000000000,
  0b00001111111111000000000000000000,
  0b00000111111110000000000000000000,

  0b00000111111110000000000000000000,
  0b00001111111111000000000000000000,
  0b00111111111111110000000000000000,
  0b01111110000111111000000000000000,
  0b11111100000011111100000000000000,
  0b11111100000000000000000000000000,
  0b11111100000000000000000000000000,
  0b11111100000000000000000000000000,
  0b11111100000000000000000000000000,
  0b11111100111000000000000000000000,
  0b11111111111111000000000000000000,
  0b11111111111111110000000000000000,
  0b11111110000111111000000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b01111110000111111000000000000000,
  0b00111111111111110000000000000000,
  0b00001111111111000000000000000000,
  0b00000111111110000000000000000000,

  0b11111111111111111100000000000000,
  0b11111111111111111100000000000000,
  0b11111111111111111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000111111000000000000000,
  0b00000000000111111000000000000000,
  0b00000000001111110000000000000000,
  0b00000000001111110000000000000000,
  0b00000000011111100000000000000000,
  0b00000000011111100000000000000000,
  0b00000000111111000000000000000000,
  0b00000000111111000000000000000000,
  0b00000001111110000000000000000000,
  0b00000001111110000000000000000000,
  0b00000011111100000000000000000000,
  0b00000011111100000000000000000000,
  0b00000111111000000000000000000000,
  0b00000111111000000000000000000000,
  0b00001111110000000000000000000000,
  0b00001111110000000000000000000000,
  0b00011111100000000000000000000000,
  0b00011111100000000000000000000000,

  0b00000111111110000000000000000000,
  0b00001111111111000000000000000000,
  0b00111111111111110000000000000000,
  0b01111110000111111000000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b01111110000111111000000000000000,
  0b00111111111111110000000000000000,
  0b00001111111111000000000000000000,
  0b00111111111111110000000000000000,
  0b01111110000111111000000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b01111110000111111000000000000000,
  0b00111111111111110000000000000000,
  0b00001111111111000000000000000000,
  0b00000111111110000000000000000000,

  0b00000111111110000000000000000000,
  0b00001111111111000000000000000000,
  0b00111111111111110000000000000000,
  0b01111110000111111000000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b11111100000011111100000000000000,
  0b01111110000111111100000000000000,
  0b00111111111111111100000000000000,
  0b00001111111111111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b00000000000011111100000000000000,
  0b11111100000011111100000000000000,
  0b01111110000111111000000000000000,
  0b00111111111111110000000000000000,
  0b00001111111111000000000000000000,
  0b00000111111110000000000000000000

};
static const uint16_t Font6x8[] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // sp
  0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000, 0x2000, 0x0000,  // !
  0x5000, 0x5000, 0x5000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // "
  0x5000, 0x5000, 0xf800, 0x5000, 0xf800, 0x5000, 0x5000, 0x0000,  // #
  0x2000, 0x7800, 0xa000, 0x7000, 0x2800, 0xf000, 0x2000, 0x0000,  // $
  0xc000, 0xc800, 0x1000, 0x2000, 0x4000, 0x9800, 0x1800, 0x0000,  // %
  0x4000, 0xa000, 0xa000, 0x4000, 0xa800, 0x9000, 0x6800, 0x0000,  // &
  0x3000, 0x3000, 0x2000, 0x4000, 0x0000, 0x0000, 0x0000, 0x0000,  // '
  0x1000, 0x2000, 0x4000, 0x4000, 0x4000, 0x2000, 0x1000, 0x0000,  // (
  0x4000, 0x2000, 0x1000, 0x1000, 0x1000, 0x2000, 0x4000, 0x0000,  // )
  0x2000, 0xa800, 0x7000, 0xf800, 0x7000, 0xa800, 0x2000, 0x0000,  // *
  0x0000, 0x2000, 0x2000, 0xf800, 0x2000, 0x2000, 0x0000, 0x0000,  // +
  0x0000, 0x0000, 0x0000, 0x0000, 0x3000, 0x3000, 0x2000, 0x0000,  // ,
  0x0000, 0x0000, 0x0000, 0xf800, 0x0000, 0x0000, 0x0000, 0x0000,  // -
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3000, 0x3000, 0x0000,  // .
  0x0000, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0000, 0x0000,  // /
  0x7000, 0x8800, 0x9800, 0xa800, 0xc800, 0x8800, 0x7000, 0x0000,  // 0
  0x2000, 0x6000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000,  // 1
  0x7000, 0x8800, 0x0800, 0x7000, 0x8000, 0x8000, 0xf800, 0x0000,  // 2
  0xf800, 0x0800, 0x1000, 0x3000, 0x0800, 0x8800, 0x7000, 0x0000,  // 3
  0x1000, 0x3000, 0x5000, 0x9000, 0xf800, 0x1000, 0x1000, 0x0000,  // 4
  0xf800, 0x8000, 0xf000, 0x0800, 0x0800, 0x8800, 0x7000, 0x0000,  // 5
  0x3800, 0x4000, 0x8000, 0xf000, 0x8800, 0x8800, 0x7000, 0x0000,  // 6
  0xf800, 0x0800, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0000,  // 7
  0x7000, 0x8800, 0x8800, 0x7000, 0x8800, 0x8800, 0x7000, 0x0000,  // 8
  0x7000, 0x8800, 0x8800, 0x7800, 0x0800, 0x1000, 0xe000, 0x0000,  // 9
  0x0000, 0x0000, 0x2000, 0x0000, 0x2000, 0x0000, 0x0000, 0x0000,  // :
  0x0000, 0x0000, 0x2000, 0x0000, 0x2000, 0x2000, 0x4000, 0x0000,  // ;
  0x0800, 0x1000, 0x2000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0000,  // <
  0x0000, 0x0000, 0xf800, 0x0000, 0xf800, 0x0000, 0x0000, 0x0000,  // =
  0x4000, 0x2000, 0x1000, 0x0800, 0x1000, 0x2000, 0x4000, 0x0000,  // >
  0x7000, 0x8800, 0x0800, 0x3000, 0x2000, 0x0000, 0x2000, 0x0000,  // ?
  0x7000, 0x8800, 0xa800, 0xb800, 0xb000, 0x8000, 0x7800, 0x0000,  // @
  0x2000, 0x5000, 0x8800, 0x8800, 0xf800, 0x8800, 0x8800, 0x0000,  // A
  0xf000, 0x8800, 0x8800, 0xf000, 0x8800, 0x8800, 0xf000, 0x0000,  // B
  0x7000, 0x8800, 0x8000, 0x8000, 0x8000, 0x8800, 0x7000, 0x0000,  // C
  0xf000, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0xf000, 0x0000,  // D
  0xf800, 0x8000, 0x8000, 0xf000, 0x8000, 0x8000, 0xf800, 0x0000,  // E
  0xf800, 0x8000, 0x8000, 0xf000, 0x8000, 0x8000, 0x8000, 0x0000,  // F
  0x7800, 0x8800, 0x8000, 0x8000, 0x9800, 0x8800, 0x7800, 0x0000,  // G
  0x8800, 0x8800, 0x8800, 0xf800, 0x8800, 0x8800, 0x8800, 0x0000,  // H
  0x7000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000,  // I
  0x3800, 0x1000, 0x1000, 0x1000, 0x1000, 0x9000, 0x6000, 0x0000,  // J
  0x8800, 0x9000, 0xa000, 0xc000, 0xa000, 0x9000, 0x8800, 0x0000,  // K
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0xf800, 0x0000,  // L
  0x8800, 0xd800, 0xa800, 0xa800, 0xa800, 0x8800, 0x8800, 0x0000,  // M
  0x8800, 0x8800, 0xc800, 0xa800, 0x9800, 0x8800, 0x8800, 0x0000,  // N
  0x7000, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000,  // O
  0xf000, 0x8800, 0x8800, 0xf000, 0x8000, 0x8000, 0x8000, 0x0000,  // P
  0x7000, 0x8800, 0x8800, 0x8800, 0xa800, 0x9000, 0x6800, 0x0000,  // Q
  0xf000, 0x8800, 0x8800, 0xf000, 0xa000, 0x9000, 0x8800, 0x0000,  // R
  0x7000, 0x8800, 0x8000, 0x7000, 0x0800, 0x8800, 0x7000, 0x0000,  // S
  0xf800, 0xa800, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000,  // T
  0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000,  // U
  0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x5000, 0x2000, 0x0000,  // V
  0x8800, 0x8800, 0x8800, 0xa800, 0xa800, 0xa800, 0x5000, 0x0000,  // W
  0x8800, 0x8800, 0x5000, 0x2000, 0x5000, 0x8800, 0x8800, 0x0000,  // X
  0x8800, 0x8800, 0x5000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000,  // Y
  0xf800, 0x0800, 0x1000, 0x7000, 0x4000, 0x8000, 0xf800, 0x0000,  // Z
  0x7800, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x7800, 0x0000,  // [
  0x0000, 0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0000, 0x0000,  /* \ */
  0x7800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x7800, 0x0000,  // ]
  0x2000, 0x5000, 0x8800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // ^
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xf800, 0x0000,  // _
  0x6000, 0x6000, 0x2000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000,  // `
  0x0000, 0x0000, 0x6000, 0x1000, 0x7000, 0x9000, 0x7800, 0x0000,  // a
  0x8000, 0x8000, 0xb000, 0xc800, 0x8800, 0xc800, 0xb000, 0x0000,  // b
  0x0000, 0x0000, 0x7000, 0x8800, 0x8000, 0x8800, 0x7000, 0x0000,  // c
  0x0800, 0x0800, 0x6800, 0x9800, 0x8800, 0x9800, 0x6800, 0x0000,  // d
  0x0000, 0x0000, 0x7000, 0x8800, 0xf800, 0x8000, 0x7000, 0x0000,  // e
  0x1000, 0x2800, 0x2000, 0x7000, 0x2000, 0x2000, 0x2000, 0x0000,  // f
  0x0000, 0x0000, 0x7000, 0x9800, 0x9800, 0x6800, 0x0800, 0x0000,  // g
  0x8000, 0x8000, 0xb000, 0xc800, 0x8800, 0x8800, 0x8800, 0x0000,  // h
  0x2000, 0x0000, 0x6000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000,  // i
  0x1000, 0x0000, 0x1000, 0x1000, 0x1000, 0x9000, 0x6000, 0x0000,  // j
  0x8000, 0x8000, 0x9000, 0xa000, 0xc000, 0xa000, 0x9000, 0x0000,  // k
  0x6000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000,  // l
  0x0000, 0x0000, 0xd000, 0xa800, 0xa800, 0xa800, 0xa800, 0x0000,  // m
  0x0000, 0x0000, 0xb000, 0xc800, 0x8800, 0x8800, 0x8800, 0x0000,  // n
  0x0000, 0x0000, 0x7000, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000,  // o
  0x0000, 0x0000, 0xb000, 0xc800, 0xc800, 0xb000, 0x8000, 0x0000,  // p
  0x0000, 0x0000, 0x6800, 0x9800, 0x9800, 0x6800, 0x0800, 0x0000,  // q
  0x0000, 0x0000, 0xb000, 0xc800, 0x8000, 0x8000, 0x8000, 0x0000,  // r
  0x0000, 0x0000, 0x7800, 0x8000, 0x7000, 0x0800, 0xf000, 0x0000,  // s
  0x2000, 0x2000, 0xf800, 0x2000, 0x2000, 0x2800, 0x1000, 0x0000,  // t
  0x0000, 0x0000, 0x8800, 0x8800, 0x8800, 0x9800, 0x6800, 0x0000,  // u
  0x0000, 0x0000, 0x8800, 0x8800, 0x8800, 0x5000, 0x2000, 0x0000,  // v
  0x0000, 0x0000, 0x8800, 0x8800, 0xa800, 0xa800, 0x5000, 0x0000,  // w
  0x0000, 0x0000, 0x8800, 0x5000, 0x2000, 0x5000, 0x8800, 0x0000,  // x
  0x0000, 0x0000, 0x8800, 0x8800, 0x7800, 0x0800, 0x8800, 0x0000,  // y
  0x0000, 0x0000, 0xf800, 0x1000, 0x2000, 0x4000, 0xf800, 0x0000,  // z
  0x1000, 0x2000, 0x2000, 0x4000, 0x2000, 0x2000, 0x1000, 0x0000,  // {
  0x2000, 0x2000, 0x2000, 0x0000, 0x2000, 0x2000, 0x2000, 0x0000,  // |
  0x4000, 0x2000, 0x2000, 0x1000, 0x2000, 0x2000, 0x4000, 0x0000,  // }
  0x4000, 0xa800, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // ~
};
static const uint16_t Font7x10[] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // sp
  0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x1000, 0x0000, 0x0000,  // !
  0x2800, 0x2800, 0x2800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // "
  0x2400, 0x2400, 0x7C00, 0x2400, 0x4800, 0x7C00, 0x4800, 0x4800, 0x0000, 0x0000,  // #
  0x3800, 0x5400, 0x5000, 0x3800, 0x1400, 0x5400, 0x5400, 0x3800, 0x1000, 0x0000,  // $
  0x2000, 0x5400, 0x5800, 0x3000, 0x2800, 0x5400, 0x1400, 0x0800, 0x0000, 0x0000,  // %
  0x1000, 0x2800, 0x2800, 0x1000, 0x3400, 0x4800, 0x4800, 0x3400, 0x0000, 0x0000,  // &
  0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // '
  0x0800, 0x1000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x1000, 0x0800,  // (
  0x2000, 0x1000, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x1000, 0x2000,  // )
  0x1000, 0x3800, 0x1000, 0x2800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // *
  0x0000, 0x0000, 0x1000, 0x1000, 0x7C00, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000,  // +
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x1000, 0x1000,  // ,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3800, 0x0000, 0x0000, 0x0000, 0x0000,  // -
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000,  // .
  0x0800, 0x0800, 0x1000, 0x1000, 0x1000, 0x1000, 0x2000, 0x2000, 0x0000, 0x0000,  // /
  0x3800, 0x4400, 0x4400, 0x5400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // 0
  0x1000, 0x3000, 0x5000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // 1
  0x3800, 0x4400, 0x4400, 0x0400, 0x0800, 0x1000, 0x2000, 0x7C00, 0x0000, 0x0000,  // 2
  0x3800, 0x4400, 0x0400, 0x1800, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000, 0x0000,  // 3
  0x0800, 0x1800, 0x2800, 0x2800, 0x4800, 0x7C00, 0x0800, 0x0800, 0x0000, 0x0000,  // 4
  0x7C00, 0x4000, 0x4000, 0x7800, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000, 0x0000,  // 5
  0x3800, 0x4400, 0x4000, 0x7800, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // 6
  0x7C00, 0x0400, 0x0800, 0x1000, 0x1000, 0x2000, 0x2000, 0x2000, 0x0000, 0x0000,  // 7
  0x3800, 0x4400, 0x4400, 0x3800, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // 8
  0x3800, 0x4400, 0x4400, 0x4400, 0x3C00, 0x0400, 0x4400, 0x3800, 0x0000, 0x0000,  // 9
  0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000,  // :
  0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x1000, 0x1000, 0x1000,  // ;
  0x0000, 0x0000, 0x0C00, 0x3000, 0x4000, 0x3000, 0x0C00, 0x0000, 0x0000, 0x0000,  // <
  0x0000, 0x0000, 0x0000, 0x7C00, 0x0000, 0x7C00, 0x0000, 0x0000, 0x0000, 0x0000,  // =
  0x0000, 0x0000, 0x6000, 0x1800, 0x0400, 0x1800, 0x6000, 0x0000, 0x0000, 0x0000,  // >
  0x3800, 0x4400, 0x0400, 0x0800, 0x1000, 0x1000, 0x0000, 0x1000, 0x0000, 0x0000,  // ?
  0x3800, 0x4400, 0x4C00, 0x5400, 0x5C00, 0x4000, 0x4000, 0x3800, 0x0000, 0x0000,  // @
  0x1000, 0x2800, 0x2800, 0x2800, 0x2800, 0x7C00, 0x4400, 0x4400, 0x0000, 0x0000,  // A
  0x7800, 0x4400, 0x4400, 0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x0000, 0x0000,  // B
  0x3800, 0x4400, 0x4000, 0x4000, 0x4000, 0x4000, 0x4400, 0x3800, 0x0000, 0x0000,  // C
  0x7000, 0x4800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4800, 0x7000, 0x0000, 0x0000,  // D
  0x7C00, 0x4000, 0x4000, 0x7C00, 0x4000, 0x4000, 0x4000, 0x7C00, 0x0000, 0x0000,  // E
  0x7C00, 0x4000, 0x4000, 0x7800, 0x4000, 0x4000, 0x4000, 0x4000, 0x0000, 0x0000,  // F
  0x3800, 0x4400, 0x4000, 0x4000, 0x5C00, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // G
  0x4400, 0x4400, 0x4400, 0x7C00, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000, 0x0000,  // H
  0x3800, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x3800, 0x0000, 0x0000,  // I
  0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000, 0x0000,  // J
  0x4400, 0x4800, 0x5000, 0x6000, 0x5000, 0x4800, 0x4800, 0x4400, 0x0000, 0x0000,  // K
  0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x7C00, 0x0000, 0x0000,  // L
  0x4400, 0x6C00, 0x6C00, 0x5400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000, 0x0000,  // M
  0x4400, 0x6400, 0x6400, 0x5400, 0x5400, 0x4C00, 0x4C00, 0x4400, 0x0000, 0x0000,  // N
  0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // O
  0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x4000, 0x4000, 0x4000, 0x0000, 0x0000,  // P
  0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x5400, 0x3800, 0x0400, 0x0000,  // Q
  0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x4800, 0x4800, 0x4400, 0x0000, 0x0000,  // R
  0x3800, 0x4400, 0x4000, 0x3000, 0x0800, 0x0400, 0x4400, 0x3800, 0x0000, 0x0000,  // S
  0x7C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // T
  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // U
  0x4400, 0x4400, 0x4400, 0x2800, 0x2800, 0x2800, 0x1000, 0x1000, 0x0000, 0x0000,  // V
  0x4400, 0x4400, 0x5400, 0x5400, 0x5400, 0x6C00, 0x2800, 0x2800, 0x0000, 0x0000,  // W
  0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x2800, 0x2800, 0x4400, 0x0000, 0x0000,  // X
  0x4400, 0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // Y
  0x7C00, 0x0400, 0x0800, 0x1000, 0x1000, 0x2000, 0x4000, 0x7C00, 0x0000, 0x0000,  // Z
  0x1800, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1800,  // [
  0x2000, 0x2000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0800, 0x0800, 0x0000, 0x0000,  /* \ */
  0x3000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x3000,  // ]
  0x1000, 0x2800, 0x2800, 0x4400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // ^
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFE00,  // _
  0x2000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // `
  0x0000, 0x0000, 0x3800, 0x4400, 0x3C00, 0x4400, 0x4C00, 0x3400, 0x0000, 0x0000,  // a
  0x4000, 0x4000, 0x5800, 0x6400, 0x4400, 0x4400, 0x6400, 0x5800, 0x0000, 0x0000,  // b
  0x0000, 0x0000, 0x3800, 0x4400, 0x4000, 0x4000, 0x4400, 0x3800, 0x0000, 0x0000,  // c
  0x0400, 0x0400, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0000, 0x0000,  // d
  0x0000, 0x0000, 0x3800, 0x4400, 0x7C00, 0x4000, 0x4400, 0x3800, 0x0000, 0x0000,  // e
  0x0C00, 0x1000, 0x7C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // f
  0x0000, 0x0000, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0400, 0x7800,  // g
  0x4000, 0x4000, 0x5800, 0x6400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000, 0x0000,  // h
  0x1000, 0x0000, 0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // i
  0x1000, 0x0000, 0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0xE000,  // j
  0x4000, 0x4000, 0x4800, 0x5000, 0x6000, 0x5000, 0x4800, 0x4400, 0x0000, 0x0000,  // k
  0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000,  // l
  0x0000, 0x0000, 0x7800, 0x5400, 0x5400, 0x5400, 0x5400, 0x5400, 0x0000, 0x0000,  // m
  0x0000, 0x0000, 0x5800, 0x6400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000, 0x0000,  // n
  0x0000, 0x0000, 0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000, 0x0000,  // o
  0x0000, 0x0000, 0x5800, 0x6400, 0x4400, 0x4400, 0x6400, 0x5800, 0x4000, 0x4000,  // p
  0x0000, 0x0000, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0400, 0x0400,  // q
  0x0000, 0x0000, 0x5800, 0x6400, 0x4000, 0x4000, 0x4000, 0x4000, 0x0000, 0x0000,  // r
  0x0000, 0x0000, 0x3800, 0x4400, 0x3000, 0x0800, 0x4400, 0x3800, 0x0000, 0x0000,  // s
  0x2000, 0x2000, 0x7800, 0x2000, 0x2000, 0x2000, 0x2000, 0x1800, 0x0000, 0x0000,  // t
  0x0000, 0x0000, 0x4400, 0x4400, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0000, 0x0000,  // u
  0x0000, 0x0000, 0x4400, 0x4400, 0x2800, 0x2800, 0x2800, 0x1000, 0x0000, 0x0000,  // v
  0x0000, 0x0000, 0x5400, 0x5400, 0x5400, 0x6C00, 0x2800, 0x2800, 0x0000, 0x0000,  // w
  0x0000, 0x0000, 0x4400, 0x2800, 0x1000, 0x1000, 0x2800, 0x4400, 0x0000, 0x0000,  // x
  0x0000, 0x0000, 0x4400, 0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x1000, 0x6000,  // y
  0x0000, 0x0000, 0x7C00, 0x0800, 0x1000, 0x2000, 0x4000, 0x7C00, 0x0000, 0x0000,  // z
  0x1800, 0x1000, 0x1000, 0x1000, 0x2000, 0x2000, 0x1000, 0x1000, 0x1000, 0x1800,  // {
  0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,  // |
  0x3000, 0x1000, 0x1000, 0x1000, 0x0800, 0x0800, 0x1000, 0x1000, 0x1000, 0x3000,  // }
  0x0000, 0x0000, 0x0000, 0x7400, 0x4C00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  // ~
};
uint8_t font7seg[] = {
  0x77,  //0
  0x14,  //1
  0xB3,  //2
  0xB6,  //3
  0xd4,  //4
  0xe6,  //5
  0xe7,  //6
  0x34,  //7
  0xf7,  //8
  0xf6,  //9
  0x83,  //c 10
  0x97,  //d 11
  0xc5,  //h 12
  0x41,  //i 13
  0x85,  //n 14
  0xf1,  //p 15
  0x87,  //o 16
  0x00,  //  17
  0xff,  //  18 
  0xf5,  // A 19
  0x60,  // kettospont 20
  0xC3   //t 21
};

#define DEBUG true          // change to false to stop Serial output if you use a display such as LED or LCD
#include <FS.h>             //this needs to be first, or it all crashes and burns...
#include <WiFiManager.h>    // https://github.com/tzapu/WiFiManager
#include <TM1637Display.h>  //https://github.com/avishorp/TM1637/tree/master
#include <string.h>
#include <stdint.h>
#include <TimeLib.h>    // https://github.com/PaulStoffregen/Time
#include <Timezone.h>   // https://github.com/JChristensen/Timezone
#include <DS3232RTC.h>  // https://github.com/JChristensen/DS3232RTC
#include <Streaming.h>  // https://github.com/geneReeves/ArduinoStreaming
#include <SPI.h>
#include <WiFi.h>
#include <WiFiUdp.h>
#include <SPIFFS.h>
#include <ArduinoJson.h>  // https://github.com/bblanchon/ArduinoJson
#include <Adafruit_NeoPixel.h>
#include <Adafruit_GPS.h>




#define TRIGGER_PIN 0
#define CLK 16
#define DIO 15
#define PWMPIN 7
#define RTC_INTERRUPT_PIN 9  // interrupt on GPIO 12
#define LATCHPIN 14
#define OEPIN 3
#define VSPI_MISO MISO
#define VSPI_MOSI MOSI
#define VSPI_SCLK SCK
#define VSPI_SS SS

#define STATUS_CONNERROR 0
#define STATUS_CONN_START 1
#define STATUS_CONN_OK 2
#define STATUS_RUNNING 3

#define UDP_LISTEN_PORT 8888
#define VSPI FSPI


#define GPSSerial Serial1

// Connect to the GPS on the hardware port
Adafruit_GPS GPS(&GPSSerial);

#define BLOCKSX 4
Adafruit_NeoPixel led(1, 48, NEO_GRB + NEO_KHZ800);
uint8_t sevenSegBuff[5];

char spiffs_SSID[30] = "GMPuc6";
char spiffs_PASSWORD[30] = "75000000";

char spiffs_DHCP[2] = "1";
char spiffs_IP_ADDR[30] = "192.168.1.123";
char spiffs_IP_GATE[30] = "192.168.1.1";
char spiffs_IP_MASK[30] = "255.255.255.0";
char spiffs_IP_ACCESS[30] = "192.168.4.10";
char spiffs_AP_TIMEOUT[40] = "NARVAL CLOCK 1";
char spiffs_NTP_IP[30] = "192.168.1.100";
char spiffs_NTP_URL[40] = "time.windows.com";
char spiffs_NTP_DAYLIGHT[30] = "1";
char spiffs_NTP_TIMEZONE[30] = "CE";
char spiffs_NTP_GPSENABLE[30] = "0";
char spiffs_BRIGHTNESS_AUTOMANUAL[30] = "0";
char spiffs_BRIGHTNESS_VAL[30] = "32";
char spiffs_COLON_BLINK[30] = "1";
char spiffs_DISPLAY_SIZE[40] = "32";


#define MILLIS_MIN 2000UL                     // 2 seconds
#define MILLIS_MAX 4294967295UL - MILLIS_MIN  // value - 2000 (2 seconds)

const char* weekdays[8] = { "Err", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
const char* months[13] = { "Err", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

bool ntpFetchFlag = false, ntpSetFlag = false, timeSynced = false, ntpFailFlag = false;
uint32_t rtcSetDelay = 0;
uint8_t ntpFailCounter = 0;
bool connected = false;

bool gpsFetchFlag;

uint32_t gpsFetchTimer;


WiFiManagerParameter custom_ipconfig_text                 ("<b><center>IP CONFIGURATION</center></b>");//////////////////////////////////////////
WiFiManagerParameter custom_dhcp                          ("dhcp", "DHCP settings:(1:on,0:off)", spiffs_DHCP, 40);
WiFiManagerParameter custom_ip_addr                       ("ip_addr", "Static ip address(only valid if dhcp = 0)", spiffs_IP_ADDR, 40);
WiFiManagerParameter custom_ip_gate                       ("ip_gate", "Static gateway address(only valid if dhcp = 0)", spiffs_IP_GATE, 40);
WiFiManagerParameter custom_ip_mask                       ("ip_mask", "Static subnet mask(only valid if dhcp = 0)", spiffs_IP_MASK, 40);
WiFiManagerParameter custom_ip_access                     ("ip_access", "Access point ip address(requires restart)", spiffs_IP_ACCESS, 40);
WiFiManagerParameter custom_ap_timeout                    ("ap_timeout", "Clock ID(max 40 char)", spiffs_AP_TIMEOUT, 40);
WiFiManagerParameter custom_ntpconfig_text                ("<b><center>NTP CONFIGURATION</center></b>");//////////////////////////////////////////
WiFiManagerParameter custom_ntp_ip                        ("ntp_ip", "NTP ip server address", spiffs_NTP_IP, 40);
WiFiManagerParameter custom_ntp_url                       ("ntp_url", "NTP url(only valid if ip is set to 0)", spiffs_NTP_URL, 40);
WiFiManagerParameter custom_daylightsavings_helper        ("<p>daylight savings options:CEST CET CE</p>");//////////////////////////////////////////
WiFiManagerParameter custom_daylightsavings_helper2       ("<p>CEST: Central European Summer time CET: Central European Standard Time  CE: Automatic change</p>");//////////////////////////////////////////
WiFiManagerParameter custom_ntp_timezone                  ("ntp_timezone", "NTP timezone setting", spiffs_NTP_TIMEZONE, 40);
WiFiManagerParameter custom_ntp_gpsenable                 ("ntp_tgpsenable", "GPS enable:(1:on,0:off)", spiffs_NTP_GPSENABLE, 5);
WiFiManagerParameter custom_display_config_text           ("<b><center>DISPLAY CONFIGURATION</center></b>");////////////////////////////////////
WiFiManagerParameter custom_display_brightness_automanual ("display_brightness_automanual", "Display brightness setup(auto: 0/manual: 1)", spiffs_BRIGHTNESS_AUTOMANUAL, 40);
WiFiManagerParameter custom_display_brightness_val        ("display_brightness_val", "Display brightness set(1-100%)", spiffs_BRIGHTNESS_VAL, 40);
WiFiManagerParameter custom_display_colon_blink           ("display_colon_blink", "Display colon(double dot) blink:(1:on,0:off)", spiffs_COLON_BLINK, 40);
WiFiManagerParameter custom_display_size                  ("display_size", "Display size (16,32,4d7s)", spiffs_DISPLAY_SIZE, 40);

bool shouldSaveConfig = false;
bool shouldSaveWifiConfig = false;

void saveConfigCallback() {
  Serial.println("Should save config");
  shouldSaveConfig = true;
}


uint8_t x = 48, y = 0;
uint16_t displayData[192];
char dispbuff[50];
uint8_t timerFlag;
uint8_t toggle;
unsigned int timeout = 120;  // seconds to run for
unsigned int startTime = millis();
bool portalRunning = false;
bool startAP = true;  // start AP and webserver if true, else start only webserver
char ntpip[40] = { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                   '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                   '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                   '0', '0', '0', '0', '0', '0', '0', '0', '0', '0' };
int datacounter = 0;
int retryCounter;
// ISR variables
volatile uint32_t sysClock, ntpAlarmCounter;  // the actual clock reference & fraction in millis
volatile bool outputTimestampEnable = false;  // used to trigger output of the current time
volatile bool halfSec = false;

int dispBrightness = 128;
int dispBrightnessPercent = 50;
int ntpShouldUseIp = 0;

WiFiManager wm;
TM1637Display display(CLK, DIO);
DS3232RTC RTC;
SPIClass* vspi = NULL;

WiFiUDP ntpClient;
IPAddress apip;

boolean isIp(String str) {
  if(str.length() == 0) return false;
  for (size_t i = 0; i < str.length(); i++) {
    int c = str.charAt(i);
    if (c != '.' && (c < '0' || c > '9')) {
      return false;
    }
  }
  return true;
}


void wifiSaveConfigCallback() {
  Serial.println("Should save wifi config");
  shouldSaveWifiConfig = true;
  if (shouldSaveWifiConfig) {
    Serial.println("saving  wifi config");
    wm.getWiFiSSID().toCharArray(spiffs_SSID, wm.getWiFiSSID().length() + 1);
    wm.getWiFiPass().toCharArray(spiffs_PASSWORD, wm.getWiFiPass().length() + 1);



    Serial.println(spiffs_SSID);
    Serial.println(spiffs_PASSWORD);
    DynamicJsonDocument json(1024);

    json["SSID"] = spiffs_SSID;
    json["PASSWORD"] = spiffs_PASSWORD;

    json["DHCP_ONOFF"] = spiffs_DHCP;
    json["STATIC_IP_ADD"] = spiffs_IP_ADDR;
    json["STATIC_DEF_GATE"] = spiffs_IP_GATE;
    json["STATIC_SUBNET"] = spiffs_IP_MASK;
    json["ACCESS_POINT_IP"] = spiffs_IP_ACCESS;
    json["ACCESS_POINT_TIMEOUT"] = spiffs_AP_TIMEOUT;
    json["NTP_ADD"] = spiffs_NTP_IP;
    json["NTP_URL"] = spiffs_NTP_URL;
    json["NTP_DAYLIGHTSAVINGS"] = spiffs_NTP_DAYLIGHT;
    json["NTP_TIMEZONE"] = spiffs_NTP_TIMEZONE;
    json["NTP_GPSENABLE"] = spiffs_NTP_GPSENABLE;
    json["BRIGHTNESS_AUTOMANUAL"] = spiffs_BRIGHTNESS_AUTOMANUAL;
    json["BRIGHTNESS_VAL"] = spiffs_BRIGHTNESS_VAL;
    json["DISPLAY_COLON_BLINK"] = spiffs_COLON_BLINK;
    json["DISPLAY_SIZE"] = spiffs_DISPLAY_SIZE;

    File configFile = SPIFFS.open("/config.json", "w");
    if (!configFile) {
      Serial.println("failed to open config file for writing");
    }
    serializeJson(json, Serial);
    serializeJson(json, configFile);
    configFile.close();
    //end save
    shouldSaveWifiConfig = false;
  }
  apip.fromString(spiffs_IP_ACCESS);
  wm.setAPStaticIPConfig(apip,apip, IPAddress(255,255,255,0));
  if(WiFi.status() != WL_CONNECTED )
  {
    connected = 0;
  }
  wm.setConfigPortalTimeout(120);
  wm.setConfigPortalBlocking(false);
  wm.startConfigPortal(spiffs_AP_TIMEOUT);
  
}

/* TIMEZONE */
/*
   Pre-defined timezone definition examples. Use only one of these at a time or risk running
   out of memory on a small AVR e.g. ATmega328. Replace the example UK timezone definition
   with one of these. See the Timezone library documentation for further details.

  // US Eastern Time Zone (New York, Detroit)
  TimeChangeRule usEDT = {"EDT", Second, Sun, Mar, 2, -240};  // Eastern Daylight Time = UTC - 4 hours
  TimeChangeRule usEST = {"EST", First, Sun, Nov, 2, -300};   // Eastern Standard Time = UTC - 5 hours
  Timezone usET(usEDT, usEST);

  // US Central Time Zone (Chicago, Houston)
  TimeChangeRule usCDT = {"CDT", Second, dowSunday, Mar, 2, -300};
  TimeChangeRule usCST = {"CST", First, dowSunday, Nov, 2, -360};
  Timezone usCT(usCDT, usCST);

  // US Mountain Time Zone (Denver, Salt Lake City)
  TimeChangeRule usMDT = {"MDT", Second, dowSunday, Mar, 2, -360};
  TimeChangeRule usMST = {"MST", First, dowSunday, Nov, 2, -420};
  Timezone usMT(usMDT, usMST);

  // Arizona is US Mountain Time Zone but does not use DST
  Timezone usAZ(usMST, usMST);

  // US Pacific Time Zone (Las Vegas, Los Angeles)
  TimeChangeRule usPDT = {"PDT", Second, dowSunday, Mar, 2, -420};
  TimeChangeRule usPST = {"PST", First, dowSunday, Nov, 2, -480};
  Timezone usPT(usPDT, usPST);
*/
//Central European Time (Frankfurt, Paris)
TimeChangeRule CEST = { "CEST", Last, Sun, Mar, 2, 120 };  //Central European Summer Time
TimeChangeRule CET = { "CET ", Last, Sun, Oct, 3, 60 };    //Central European Standard Time
Timezone CE(CEST, CET);
Timezone CEst(CEST, CEST);
Timezone CEt(CET, CET);
/*
//United Kingdom (London, Belfast)
TimeChangeRule BST = {"BST", Last, Sun, Mar, 1, 60};        //British Summer Time
TimeChangeRule GMT = {"GMT", Last, Sun, Oct, 2, 0};         //Standard Time
Timezone UK(BST, GMT);
*/
TimeChangeRule* tcr;  //pointer to the time change rule, use to get the TZ abbrev

#define TIME_ZONE CE  // change to CE for European local time etc.

/*********************/
/* FUNCTIONS AND ISR */
/*********************/


//volatile uint32_t sysFraction;  // for future development
hw_timer_t* My_timer = NULL;
void IRAM_ATTR onTimer() {
  gpsFetchTimer++;
  if(gpsFetchTimer >= 5)
  {
    gpsFetchTimer = 0;
    gpsFetchFlag = 1;
  }
}
void ICACHE_RAM_ATTR rtcIntISR(void);
// the RTC 1PPS signal calls this ISR
void ICACHE_RAM_ATTR rtcIntISR(void) {
  halfSec = digitalRead(RTC_INTERRUPT_PIN);
  outputTimestampEnable = true;  // signals OK to print out the
  if (!halfSec) {
    // This increments the sysClock and sets the outputTimestampEnable flag
    sysClock++;  // the system timestamp is incremented every second by the RTC
    //sysFraction = millis(); // for future development
    ntpAlarmCounter++;  // used to trigger NTP time fetches
  }
}  // END OF rtcIntISR

// the NTP client calls this function to read the NTP packetBuffer time values
uint32_t readNtpBuffer(uint8_t* buff, uint8_t _start) {
  // NTP data is sent as Big Endian so we need to convert it for Arduino use.
  // Reads the 4 Bytes from the NTP buffer and returns temp as Little Endian
  uint32_t temp;
  uint8_t* tmp = reinterpret_cast<uint8_t*>(&temp);
  for (uint8_t x = 0; x < 4; x++) tmp[x ^ 3] = buff[_start + x];
  return temp;
}  // END OF readNtpBuffer

/**************/
/* NTP CLIENT */
/*************/

// an array of NTP servers. The specific server is specified by the index number
// in the call to sendNTPrequest(uint8_t index)
char* ntpServer = { "time.windows.com"};  // the NTP servers for testing
IPAddress ntpServerIp;

#define NTP_TIMEOUT 500            // maximum time to wait for an NTP server response in milliseconds
#define NTP_ROUNDTRIP_MAX 200      // the maximinun NTP round-trip in milliseconds
#define NTP_FETCH_PERIOD 60        // how often to fetch NTP time in seconds
#define NTP_FAIL_COUNT 5           // the number of times to retry an NTP fetch before giving up
#define NTP_FAIL_RETRY 10          // time in seconds to wait before trying an NTP re-fetch
#define NTP_PACKET_SIZE 48         // the size of the NTP packet
#define NTP_70_YEARS 2208988800UL  // seconds between 1900 (NTP) & 1970 (UNIX)
#define SVR_TIME_SECS 40           // buffer offset for NTP timestamp
#define SVR_TIME_FRAC 44           // buffer offset for NTP fraction
uint32_t ntpTime, ntpFraction, ntpRoundtrip;
uint8_t packetBuffer[NTP_PACKET_SIZE];

// send an NTP request to the time server at the given address (ntpServer[index])
uint32_t sendNTPrequest(uint8_t index) 
{
  Serial << F("ntp_req") << endl;
  showStatus(STATUS_RUNNING);
  
  // we can send an empty packet with just the first byte header to the NTP server
  memset(&packetBuffer, 0, NTP_PACKET_SIZE);
  packetBuffer[0] = 0b11100011;
  // send the NTP packet to the server
  ntpClient.flush();  // discard any previously received packet data
  ntpFraction = 0;
  
  // send the packet and exit if error
  if(ntpShouldUseIp == 0)
  {
    Serial.println(ntpServer);
    if (!ntpClient.beginPacket(ntpServer, 123)) return 1;
  }
  else if(ntpShouldUseIp == 1)
  {
    if (!ntpClient.beginPacket(ntpServerIp, 123)) return 1;
    Serial.println(ntpServerIp);
  }
  ntpClient.write(packetBuffer, NTP_PACKET_SIZE);
  if (!ntpClient.endPacket()) return 2;
  // now wait for the response from the server
  ntpRoundtrip = millis();
  bool _timeOut = true;
  uint8_t packetSize;
  uint32_t timeOutTimer = millis();
  while ((millis() - timeOutTimer) < NTP_TIMEOUT && _timeOut) 
  {
    delay(0);  // for ESP8266 compatibility
    if (packetSize = ntpClient.parsePacket()) _timeOut = false;
  }
  ntpRoundtrip = millis() - ntpRoundtrip;
  if (_timeOut) return 3;
  if (packetSize != NTP_PACKET_SIZE) return 4;
  // we got a valid response packet so carry on and
  // extract the timestamp and fractional seconds. Convert NTP timestamp to UNIX
  while (ntpClient.available()) ntpClient.read(packetBuffer, 48);
  ntpTime = readNtpBuffer(packetBuffer, SVR_TIME_SECS) - NTP_70_YEARS;
  // the timestamp fractional seconds are picoseconds so convert to milliseconds
  // ntpFraction * 10 ^ 6 / 2 ^ 32 /1000 = milliseconds
  ntpFraction = (uint32_t)((readNtpBuffer(packetBuffer, SVR_TIME_FRAC) * pow(10, 6)) / pow(2, 32)) / 1000UL;
  return 0;
}  // END OF sendNTPrequest

void drawPixel(uint8_t x, uint8_t y, uint8_t color) 
{
  uint16_t xBlock;
  uint8_t yHighOrLow;
  uint16_t mask;
  uint16_t xPos;
  yHighOrLow = y % 2;  //if even then result is 0, 0 means the lower
  xBlock = x / 8;
  xPos = x % 8;
  int16_t yTemp;

  if (x > 31) {
    if (x < 64) {
      xBlock += 12;
    }
    if (x > 63) {
      xBlock += 24;
    }
  }

  if (y > 7) {
    if (y < 16) {
      y = y - 4;
      if( ( spiffs_DISPLAY_SIZE[0] == '3' ) && ( spiffs_DISPLAY_SIZE[1] == '2' ) )
        {
         xBlock += 40;  //here this needs to be changed back to 24 if i want to use the 2x2 grid display(idk yet why 24)
        }
      if( ( spiffs_DISPLAY_SIZE[0] == '1' ) && ( spiffs_DISPLAY_SIZE[1] == '6' ) )
        {
         xBlock += 24;  //here this needs to be changed back to 24 if i want to use the 2x2 grid display(idk yet why 24)
        }
    }
    if (y > 15) {
      y = y - 8;
      xBlock += 80;  //here this needs to be changed back to 24 if i want to use the 2x2 grid display(idk yet why 24)
    }
  }
  if (color)  //draw
  {
    if (yHighOrLow == 0) {
      displayData[xBlock + ((y / 2) * 4)] |= 1 << xPos;
    } else {
      displayData[xBlock + ((y / 2) * 4)] |= 1 << (xPos + 8);
    }
  } else  //clear
  {
    if (yHighOrLow == 0) {
      displayData[xBlock + ((y / 2) * 4)] &= ~(1 << xPos);
    } else {
      displayData[xBlock + ((y / 2) * 4)] &= ~(1 << (xPos + 8));
    }
  }
}
void sendDisplay(void) {
  digitalWrite(OEPIN, 1);
  vspi->beginTransaction(SPISettings(10000000, LSBFIRST, SPI_MODE0));

  for (int i = 0; i < 144; i++) {
    vspi->transfer16(displayData[i]);
  }
  vspi->endTransaction();
  digitalWrite(LATCHPIN, 1);
  digitalWrite(LATCHPIN, 0);
  digitalWrite(OEPIN, 0);
}
void sendDisplay16(void) {
  digitalWrite(OEPIN, 1);
  vspi->beginTransaction(SPISettings(10000000, LSBFIRST, SPI_MODE0));

  for (int i = 0; i < 64; i++) {
    vspi->transfer16(displayData[i]);
  }
  vspi->endTransaction();
  digitalWrite(LATCHPIN, 1);
  digitalWrite(LATCHPIN, 0);
  digitalWrite(OEPIN, 0);
}
void sendSevenSeg(void) {
  vspi->beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));
  /*
  display is filled from left to right so in order to write to the left digit i have 
  to send out that last(before the dots because they are the last)
  */
  vspi->transfer(sevenSegBuff[3]);  //rightmost digit
  vspi->transfer(sevenSegBuff[2]);  //2nd from the right
  vspi->transfer(sevenSegBuff[1]);  //3rd from the right
  vspi->transfer(sevenSegBuff[0]);  //4th from the right
  vspi->transfer(sevenSegBuff[4]);  //dots, from the top: 0b11100000, msb is the upper dot

  vspi->endTransaction();
  digitalWrite(LATCHPIN, LOW);
  digitalWrite(LATCHPIN, HIGH);
  delay(1);
  digitalWrite(LATCHPIN, LOW);
}
char WriteChar(char ch, uint8_t x, uint8_t y, uint8_t color) {
  uint32_t i, b, j;

  // Check if character is valid
  if (ch < 32 || ch > 126)
    return 0;

  // Use the font to write
  for (i = 0; i < 10; i++) {
    b = Font7x10[(ch - 32) * 10 + i];
    for (j = 0; j < 7; j++) {
      if ((b << j) & 0x8000) {
        drawPixel(x + j, (y + 9) - i, color);
      } else {
        drawPixel(x + j, (y + 9) - i, !color);
      }
    }
  }
  return ch;
}
char WriteChar6x8(char ch, uint8_t x, uint8_t y, uint8_t color) {
  uint32_t i, b, j;

  // Check if character is valid
  if (ch < 32 || ch > 126)
    return 0;

  // Use the font to write
  for (i = 0; i < 8; i++) {
    b = Font6x8[(ch - 32) * 8 + i];
    for (j = 0; j < 6; j++) {
      if ((b << j) & 0x8000) {
        drawPixel(x + j, (y + 7) - i, color);
      } else {
        drawPixel(x + j, (y + 7) - i, !color);
      }
    }
  }
  return ch;
}
char WriteBigChar(char ch, uint8_t x, uint8_t y, uint8_t color) {
  uint32_t xt, yt, i, f, j;

  // Check if character is valid
  if (ch < 48 || ch > 57)
    return 0;

  // Use the font to write
  for (i = 0; i < 16; i++) {
    f = Font13x16[(ch - 48) * 16 + i];
    for (j = 0; j < 13; j++) {
      if ((f << j) & 0x8000) {
        drawPixel(x + j, 15 - i, 1);
      } else {
        drawPixel(x + j, 15 - i, !1);
      }
    }
  }
  return ch;
}
char WriteBiggerChar(char ch, uint8_t x, uint8_t y, uint8_t color) {
  uint32_t xt, yt, i, f, j;

  // Check if character is valid
  if (ch < 48 || ch > 57)
    return 0;

  // Use the font to write
  for (i = 0; i < 24; i++) {
    f = Font18x24[(ch - 48) * 24 + i];
    for (j = 0; j < 18; j++) {
      if ((f << j) & 0x80000000) {
        drawPixel(x + j, 23 - i, 1);
      } else {
        drawPixel(x + j, 23 - i, !1);
      }
    }
  }
  return ch;
}
void writeChar7Seg(char ch, uint8_t pos) {
  if (pos > 4) {
    return;
  }
  sevenSegBuff[pos] = font7seg[ch - 0x30];
  sendSevenSeg();
}
void dispTest(void) {
  for (int x = 0; x < 4; x++) {
    memset(sevenSegBuff, 0, sizeof(sevenSegBuff));
    writeChar7Seg('8', x);
    delay(500);
  }
  for (int i = 0; i < 8; i++) {
    vspi->beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));
    vspi->transfer(1 << i);
    vspi->transfer(1 << i);
    vspi->transfer(1 << i);
    vspi->transfer(1 << i);
    vspi->transfer(1 << i);

    vspi->endTransaction();
    digitalWrite(LATCHPIN, LOW);
    digitalWrite(LATCHPIN, HIGH);
    delay(1);
    digitalWrite(LATCHPIN, LOW);
    delay(500);
  }
}
void showStatus(uint8_t status) {
  switch (status) {
    case 0:  //STATUS_CONNERROR
      {
        led.setPixelColor(0, led.Color(255, 0, 0));
        led.show();
        break;
      }
    case 1:  //STATUS_CONN_START
      {
        led.setPixelColor(0, led.Color(250, 100, 0));
        led.show();
        break;
      }
    case 2:  //STATUS_CONN_OK
      {
        led.setPixelColor(0, led.Color(0, 0, 255));
        led.show();
        break;
      }
    case 3:  //STATUS_RUNNING
      {
        led.setPixelColor(0, led.Color(0, 255, 0));
        led.show();
        break;
      }
  }
}
void setBrightness(int percent)
{
  ledcWrite(4, map(percent,100,0,0,255));
}
void printApIp3x3(void)
{
  memset(displayData, 0x00, 144 * 2);
        WriteChar6x8('N', 0,0,1);//n
        WriteChar6x8('O', 8,0,1);//n
        WriteChar6x8(' ', 16,0,1);//n
        WriteChar6x8('C', 24,0,1);//n
        WriteChar6x8('O', 32,0,1);//n
        WriteChar6x8('N', 40,0,1);//n
        WriteChar6x8('N', 48,0,1);//n

        WriteChar6x8('A', 0,8,1);//n
        WriteChar6x8('P', 8,8,1);//n
        WriteChar6x8(' ', 16,8,1);//n
        WriteChar6x8('I', 24,8,1);//n
        WriteChar6x8('P', 32,8,1);//n
        WriteChar6x8(':', 40,8,1);//n
        int num,hundred,ten;
        num = apip[0];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 0,0,1);//n
        WriteChar6x8(ten+0x30, 6,0,1);//n
        WriteChar6x8(num+0x30, 12,0,1);//n
        WriteChar6x8('.', 18,0,1);//n
        num = apip[1];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 24,0,1);//n
        WriteChar6x8(ten+0x30, 30,0,1);//n
        WriteChar6x8(num+0x30, 36,0,1);//n
        WriteChar6x8('.', 42,0,1);//n
        num = apip[2];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 48,0,1);//n
        WriteChar6x8(ten+0x30, 54,0,1);//n
        WriteChar6x8(num+0x30, 60,0,1);//n
        WriteChar6x8('.', 66,0,1);//n
        num = apip[3];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 72,0,1);//n
        WriteChar6x8(ten+0x30, 78,0,1);//n
        WriteChar6x8(num+0x30, 84,0,1);//n
        WriteChar6x8('.', 90,0,1);//n
sendDisplay();
delay(2000);
        
}
void printStaIp3x3(void)
{
        IPAddress ip = WiFi.localIP();
        memset(displayData, 0x00, 144 * 2);
        WriteChar6x8('S', 0,8,1);//n
        WriteChar6x8('T', 6,8,1);//n
        WriteChar6x8('A', 12,8,1);//n
        WriteChar6x8('T', 18,8,1);//n
        WriteChar6x8('I', 24,8,1);//n
        WriteChar6x8('O', 30,8,1);//n
        WriteChar6x8('N', 36,8,1);//n
        WriteChar6x8(' ', 42,8,1);//n
        WriteChar6x8('I', 48,8,1);//n
        WriteChar6x8('P', 54,8,1);//n
        WriteChar6x8(':', 60,8,1);//n

                int num,hundred,ten;
        num = ip[0];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 0,0,1);//n
        WriteChar6x8(ten+0x30, 6,0,1);//n
        WriteChar6x8(num+0x30, 12,0,1);//n
        WriteChar6x8('.', 18,0,1);//n
        num = ip[1];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 24,0,1);//n
        WriteChar6x8(ten+0x30, 30,0,1);//n
        WriteChar6x8(num+0x30, 36,0,1);//n
        WriteChar6x8('.', 42,0,1);//n
        num = ip[2];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 48,0,1);//n
        WriteChar6x8(ten+0x30, 54,0,1);//n
        WriteChar6x8(num+0x30, 60,0,1);//n
        WriteChar6x8('.', 66,0,1);//n
        num = ip[3];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 72,0,1);//n
        WriteChar6x8(ten+0x30, 78,0,1);//n
        WriteChar6x8(num+0x30, 84,0,1);//n
        WriteChar6x8('.', 90,0,1);//n
sendDisplay();
delay(2000);
}



void printApIp2x2(void)
{
  memset(displayData, 0x00, 144 * 2);
        WriteChar6x8('N', 0,0,1);//n
        WriteChar6x8('O', 8,0,1);//n
        WriteChar6x8(' ', 16,0,1);//n
        WriteChar6x8('C', 24,0,1);//n
        WriteChar6x8('O', 32,0,1);//n
        WriteChar6x8('N', 40,0,1);//n
        WriteChar6x8('N', 48,0,1);//n
sendDisplay16();
delay(2000);
 memset(displayData, 0x00, 144 * 2);
        WriteChar6x8('A', 0,8,1);//n
        WriteChar6x8('P', 8,8,1);//n
        WriteChar6x8(' ', 16,8,1);//n
        WriteChar6x8('I', 24,8,1);//n
        WriteChar6x8('P', 32,8,1);//n
        WriteChar6x8(':', 40,8,1);//n
        int num,hundred,ten;
        num = apip[0];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 0,0,1);//n
        WriteChar6x8(ten+0x30, 8,0,1);//n
        WriteChar6x8(num+0x30, 16,0,1);//n
        WriteChar6x8('.', 24,0,1);//n
        num = apip[1];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 32,0,1);//n
        WriteChar6x8(ten+0x30, 40,0,1);//n
        WriteChar6x8(num+0x30, 48,0,1);//n
        WriteChar6x8('.', 56,0,1);//n
sendDisplay16();
delay(2000);
memset(displayData, 0x00, 144 * 2);
        num = apip[2];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 0,0,1);//n
        WriteChar6x8(ten+0x30, 8,0,1);//n
        WriteChar6x8(num+0x30, 16,0,1);//n
        WriteChar6x8('.', 24,0,1);//n
        num = apip[3];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 32,0,1);//n
        WriteChar6x8(ten+0x30, 40,0,1);//n
        WriteChar6x8(num+0x30, 48,0,1);//n
        WriteChar6x8('.', 56,0,1);//n
sendDisplay16();
delay(2000);
        
}
void printStaIp2x2(void)
{
        IPAddress ip = WiFi.localIP();
        memset(displayData, 0x00, 144 * 2);
        WriteChar6x8('S', 0,0,1);//n
        WriteChar6x8('T', 8,0,1);//n
        WriteChar6x8('A', 16,0,1);//n
        WriteChar6x8(' ', 24,0,1);//n
        WriteChar6x8('I', 32,0,1);//n
        WriteChar6x8('P', 40,0,1);//n
        WriteChar6x8(':', 48,0,1);//n
sendDisplay16();
delay(2000);
memset(displayData, 0x00, 144 * 2);
        int num,hundred,ten;
        num = ip[0];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 0,0,1);//n
        WriteChar6x8(ten+0x30, 8,0,1);//n
        WriteChar6x8(num+0x30, 16,0,1);//n
        WriteChar6x8('.', 24,0,1);//n
        num = ip[1];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 32,0,1);//n
        WriteChar6x8(ten+0x30, 40,0,1);//n
        WriteChar6x8(num+0x30, 48,0,1);//n
        WriteChar6x8('.', 56,0,1);//n
sendDisplay16();
delay(2000);
memset(displayData, 0x00, 144 * 2);
        num = ip[2];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 0,0,1);//n
        WriteChar6x8(ten+0x30, 8,0,1);//n
        WriteChar6x8(num+0x30, 16,0,1);//n
        WriteChar6x8('.', 24,0,1);//n
        num = ip[3];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        WriteChar6x8(hundred+0x30, 32,0,1);//n
        WriteChar6x8(ten+0x30, 40,0,1);//n
        WriteChar6x8(num+0x30, 48,0,1);//n
        WriteChar6x8('.', 56,0,1);//n
sendDisplay16();
delay(2000);
}
void printApIp7Seg(void)
{
        writeChar7Seg(14+0x30, 0);//n
        writeChar7Seg(16+0x30, 1);//o
        writeChar7Seg(17+0x30, 2);//blank
        writeChar7Seg(17+0x30, 3);//blank
        delay(2000);
        writeChar7Seg(10+0x30, 0);//c
        writeChar7Seg(16+0x30, 1);//o
        writeChar7Seg(14+0x30, 2);//n
        writeChar7Seg(14+0x30, 3);//n
        delay(2000);
        writeChar7Seg(19+0x30, 0);//A
        writeChar7Seg(15+0x30, 1);//P
        writeChar7Seg(13+0x30, 2);//I
        writeChar7Seg(15+0x30, 3);//P
        delay(2000);
        int num,hundred,ten;
        num = apip[0];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        writeChar7Seg(hundred+0x30, 0);//
        writeChar7Seg(ten+0x30, 1);//
        writeChar7Seg(num+0x30, 2);//
        writeChar7Seg(17+0x30, 3);//
        delay(2000);
        num = apip[1];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        writeChar7Seg(hundred+0x30, 0);//
        writeChar7Seg(ten+0x30, 1);//
        writeChar7Seg(num+0x30, 2);//
        writeChar7Seg(17+0x30, 3);//
        delay(2000);
        num = apip[2];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        writeChar7Seg(hundred+0x30, 0);//
        writeChar7Seg(ten+0x30, 1);//
        writeChar7Seg(num+0x30, 2);//
        writeChar7Seg(17+0x30, 3);//
        delay(2000);
        num = apip[3];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        writeChar7Seg(hundred+0x30, 0);//
        writeChar7Seg(ten+0x30, 1);//
        writeChar7Seg(num+0x30, 2);//
        writeChar7Seg(17+0x30, 3);//
        delay(2000);
        Serial.println(apip[0]);
}
void printStaIp7Seg(void)
{
IPAddress ip = WiFi.localIP();
        writeChar7Seg(5+0x30, 0);//s
        writeChar7Seg(21+0x30, 1);//t
        writeChar7Seg(19+0x30, 2);//a
        writeChar7Seg(21+0x30, 3);//t
        delay(1000);
        writeChar7Seg(13+0x30, 0);//i
        writeChar7Seg(16+0x30, 1);//o
        writeChar7Seg(14+0x30, 2);//n
        writeChar7Seg(17+0x30, 3);//null
        delay(1000);
        writeChar7Seg(13+0x30, 0);//i
        writeChar7Seg(15+0x30, 1);//P
        writeChar7Seg(17+0x30, 2);//null
        writeChar7Seg(17+0x30, 3);//null
        delay(2000);
        int num,hundred,ten;
        num = ip[0];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        writeChar7Seg(hundred+0x30, 0);//
        writeChar7Seg(ten+0x30, 1);//
        writeChar7Seg(num+0x30, 2);//
        writeChar7Seg(17+0x30, 3);//
        delay(2000);
        num = ip[1];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        writeChar7Seg(hundred+0x30, 0);//
        writeChar7Seg(ten+0x30, 1);//
        writeChar7Seg(num+0x30, 2);//
        writeChar7Seg(17+0x30, 3);//
        delay(2000);
        num = ip[2];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        writeChar7Seg(hundred+0x30, 0);//
        writeChar7Seg(ten+0x30, 1);//
        writeChar7Seg(num+0x30, 2);//
        writeChar7Seg(17+0x30, 3);//
        delay(2000);
        num = ip[3];
        hundred = num/100;
        num = num%100;
        ten = num/10;
        num = num%10;
        writeChar7Seg(hundred+0x30, 0);//
        writeChar7Seg(ten+0x30, 1);//
        writeChar7Seg(num+0x30, 2);//
        writeChar7Seg(17+0x30, 3);//
        delay(2000);
}


void saveConfig(void) {

 
  DynamicJsonDocument json(1024);
  char testbuff[50];
  strcpy(testbuff, custom_ip_access.getValue());
   Serial.print("ip add is ip?");
  Serial.println(isIp((String)testbuff));
  if(isIp((String)testbuff))
  {
  strcpy(spiffs_DISPLAY_SIZE, custom_display_size.getValue());
  strcpy(spiffs_BRIGHTNESS_VAL, custom_display_brightness_val.getValue());
  strcpy(spiffs_COLON_BLINK, custom_display_colon_blink.getValue());
  strcpy(spiffs_BRIGHTNESS_AUTOMANUAL, custom_display_brightness_automanual.getValue());
  strcpy(spiffs_NTP_GPSENABLE, custom_ntp_gpsenable.getValue());
  strcpy(spiffs_NTP_URL, custom_ntp_url.getValue());
  strcpy(spiffs_NTP_TIMEZONE, custom_ntp_timezone.getValue());
  strcpy(spiffs_NTP_IP, custom_ntp_ip.getValue());
  strcpy(spiffs_AP_TIMEOUT, custom_ap_timeout.getValue());
  strcpy(spiffs_IP_ACCESS, custom_ip_access.getValue());
  strcpy(spiffs_IP_MASK, custom_ip_mask.getValue());
  strcpy(spiffs_IP_GATE, custom_ip_gate.getValue());
  strcpy(spiffs_IP_ADDR, custom_ip_addr.getValue());
  strcpy(spiffs_DHCP, custom_dhcp.getValue());
  Serial.println("saving config");


  json["SSID"] = spiffs_SSID;
  json["PASSWORD"] = spiffs_PASSWORD;
  json["DHCP_ONOFF"] = spiffs_DHCP;
  json["STATIC_IP_ADD"] = spiffs_IP_ADDR;
  json["STATIC_DEF_GATE"] = spiffs_IP_GATE;
  json["STATIC_SUBNET"] = spiffs_IP_MASK;
  json["ACCESS_POINT_IP"] = spiffs_IP_ACCESS;
  json["ACCESS_POINT_TIMEOUT"] = spiffs_AP_TIMEOUT;
  json["NTP_ADD"] = spiffs_NTP_IP;
  json["NTP_URL"] = spiffs_NTP_URL;
  json["NTP_DAYLIGHTSAVINGS"] = spiffs_NTP_DAYLIGHT;
  json["NTP_TIMEZONE"] = spiffs_NTP_TIMEZONE;
  json["NTP_GPSENABLE"] = spiffs_NTP_GPSENABLE;
  json["BRIGHTNESS_AUTOMANUAL"] = spiffs_BRIGHTNESS_AUTOMANUAL;
  json["BRIGHTNESS_VAL"] = spiffs_BRIGHTNESS_VAL;
  json["DISPLAY_COLON_BLINK"] = spiffs_COLON_BLINK;
  json["DISPLAY_SIZE"] = spiffs_DISPLAY_SIZE;

  File configFile = SPIFFS.open("/config.json", "w");
  if (!configFile) {
    Serial.println("failed to open config file for writing");
  }
  serializeJson(json, Serial);
  serializeJson(json, configFile);
  configFile.close();
  }

  if( ( spiffs_NTP_IP[0] == '0' ) && ( spiffs_NTP_IP[1] == 0 ))
  {
    ntpShouldUseIp = 0;
    ntpServer = spiffs_NTP_URL;
  }
  else if( isIp ( String ( spiffs_NTP_IP ) ) )
  {
    ntpServerIp.fromString(spiffs_NTP_IP);
    ntpShouldUseIp = 1;
  }
  apip.fromString(spiffs_IP_ACCESS);
  wm.setAPStaticIPConfig(apip,apip, IPAddress(255,255,255,0));
}
/**********************************************************************************************************************************************************/
/* SETUP */
/*********/
void setup() {
  showStatus(STATUS_CONN_START);
  display.setBrightness(7, true);
  WiFi.disconnect();
  vspi = new SPIClass(VSPI);
  vspi->begin(VSPI_SCLK, VSPI_MISO, VSPI_MOSI, VSPI_SS);  //SCLK, MISO, MOSI, SS
  pinMode(LATCHPIN, OUTPUT);
  pinMode(OEPIN, OUTPUT);
  memset(displayData, 0, 32);
  My_timer = timerBegin(0, 80, true);
  timerAttachInterrupt(My_timer, &onTimer, true);
  timerAlarmWrite(My_timer, 1000000, true);
  timerAlarmEnable(My_timer);  //Just Enable
  ledcSetup(4, 5000, 8);
  ledcAttachPin(6, 4);
  ledcWrite(4, 250);

  Serial.begin(57600);
  GPSSerial.begin(9600,SERIAL_8N1,17,18);
  
  Serial << F("A.N.T. Accurate Ntp Time (C) Phil Morris 2018 <www.lydiard.plus.com>") << endl;

  if (SPIFFS.begin()) 
  {
    Serial.println("mounted file system");
    if (SPIFFS.exists("/config.json")) 
    {
      //file exists, reading and loading
      Serial.println("reading config file");
      File configFile = SPIFFS.open("/config.json", "r");
      if (configFile) 
      {
        Serial.println("opened config file");
        size_t size = configFile.size();
        Serial.print("opened config file size:");
        Serial.println(size);
        // Allocate a buffer to store contents of the file.
        std::unique_ptr<char[]> buf(new char[size]);

        configFile.readBytes(buf.get(), size);
        DynamicJsonDocument json(1024);
        auto deserializeError = deserializeJson(json, buf.get());
        serializeJson(json, Serial);
        if (!deserializeError) {
          Serial.println("\nparsed json");

          strcpy(spiffs_SSID, json["SSID"]);
          strcpy(spiffs_PASSWORD, json["PASSWORD"]);
          strcpy(spiffs_DHCP, json["DHCP_ONOFF"]);
          strcpy(spiffs_IP_ADDR, json["STATIC_IP_ADD"]);
          strcpy(spiffs_IP_GATE, json["STATIC_DEF_GATE"]);
          strcpy(spiffs_IP_MASK, json["STATIC_SUBNET"]);
          strcpy(spiffs_IP_ACCESS, json["ACCESS_POINT_IP"]);
          strcpy(spiffs_AP_TIMEOUT, json["ACCESS_POINT_TIMEOUT"]);
          strcpy(spiffs_NTP_IP, json["NTP_ADD"]);
          strcpy(spiffs_NTP_URL, json["NTP_URL"]);
          strcpy(spiffs_NTP_DAYLIGHT, json["NTP_DAYLIGHTSAVINGS"]);
          strcpy(spiffs_NTP_TIMEZONE, json["NTP_TIMEZONE"]);
          strcpy(spiffs_NTP_GPSENABLE, json["NTP_GPSENABLE"]);
          strcpy(spiffs_BRIGHTNESS_AUTOMANUAL, json["BRIGHTNESS_AUTOMANUAL"]);
          strcpy(spiffs_BRIGHTNESS_VAL, json["BRIGHTNESS_VAL"]);
          strcpy(spiffs_COLON_BLINK, json["DISPLAY_COLON_BLINK"]);
          strcpy(spiffs_DISPLAY_SIZE, json["DISPLAY_SIZE"]);
          Serial.println(spiffs_SSID);
          Serial.println(spiffs_PASSWORD);
        } 
        else 
        {
          Serial.println("failed to load json config");
        }
      }
    }
  } 
  else 
  {
    Serial.println("failed to mount FS");
  }
  wm.addParameter(&custom_ipconfig_text);
  wm.addParameter(&custom_dhcp);
  wm.addParameter(&custom_ip_addr);
  wm.addParameter(&custom_ip_gate);
  wm.addParameter(&custom_ip_mask);
  wm.addParameter(&custom_ip_access);
  wm.addParameter(&custom_ap_timeout);
  wm.addParameter(&custom_ntpconfig_text);
  wm.addParameter(&custom_ntp_ip);
  wm.addParameter(&custom_ntp_url);
  wm.addParameter(&custom_daylightsavings_helper);
  wm.addParameter(&custom_daylightsavings_helper2);
  wm.addParameter(&custom_ntp_timezone);
  wm.addParameter(&custom_ntp_gpsenable);
  wm.addParameter(&custom_display_config_text);
  wm.addParameter(&custom_display_brightness_automanual);
  wm.addParameter(&custom_display_brightness_val);
  wm.addParameter(&custom_display_colon_blink);
  wm.addParameter(&custom_display_size);

  wm.setBreakAfterConfig(true);
  wm.setSaveConfigCallback(wifiSaveConfigCallback);
  wm.setSaveParamsCallback(saveConfigCallback);
  if( ( spiffs_DISPLAY_SIZE[0] == '4' ) && ( spiffs_DISPLAY_SIZE[1] == 'd' ) && ( spiffs_DISPLAY_SIZE[2] == '7' ) && ( spiffs_DISPLAY_SIZE[3] == 's' ) )
      {
      setBrightness(100);
      dispTest();
      }

//ntp server config
if( ( spiffs_NTP_IP[0] == '0' ) && ( spiffs_NTP_IP[1] == 0 ))
{
  ntpShouldUseIp = 0;
  ntpServer = spiffs_NTP_URL;
}
else if( isIp ( String ( spiffs_NTP_IP ) ) )
{
  ntpServerIp.fromString(spiffs_NTP_IP);
  ntpShouldUseIp = 1;
}
int analogVal = map(analogRead(8),0,4096,30,255);
if(spiffs_BRIGHTNESS_AUTOMANUAL[0] == '1')
  {
    String brightnessval = String(spiffs_BRIGHTNESS_VAL);
    setBrightness(brightnessval.toInt());
  }
  if(spiffs_BRIGHTNESS_AUTOMANUAL[0] == '0')
  {
    setBrightness(map(analogVal,255,30,10,100));
  }
apip.fromString(spiffs_IP_ACCESS);
wm.setAPStaticIPConfig(apip,apip, IPAddress(255,255,255,0));
if (spiffs_DHCP[0] == '1') 
  {
    WiFi.mode(WIFI_STA);
    WiFi.begin(spiffs_SSID, spiffs_PASSWORD);
    while ((WiFi.status() != WL_CONNECTED) && (retryCounter < 5)) 
    {
      delay(2000);
      retryCounter++;
    }
    if(retryCounter >= 5)
    {
      showStatus(STATUS_CONNERROR);
      wm.setConfigPortalBlocking(false);
      wm.startConfigPortal(spiffs_AP_TIMEOUT);
      Serial.println("Connection error, Starting Config Portal");
      if( ( spiffs_DISPLAY_SIZE[0] == '4' ) && ( spiffs_DISPLAY_SIZE[1] == 'd' ) && ( spiffs_DISPLAY_SIZE[2] == '7' ) && ( spiffs_DISPLAY_SIZE[3] == 's' ) )
      {
      printApIp7Seg();
      }
      if( ( spiffs_DISPLAY_SIZE[0] == '1' ) && ( spiffs_DISPLAY_SIZE[1] == '6' ) )
      {
      printApIp2x2();
      
      }
      if( ( spiffs_DISPLAY_SIZE[0] == '3' ) && ( spiffs_DISPLAY_SIZE[1] == '2' ) )
      {
      printApIp3x3();
      
      }
      delay(2000);
    }//retrycounter == 5 end
    else if( ( spiffs_DISPLAY_SIZE[0] == '4' ) && ( spiffs_DISPLAY_SIZE[1] == 'd' ) && ( spiffs_DISPLAY_SIZE[2] == '7' ) && ( spiffs_DISPLAY_SIZE[3] == 's' ) )
      {
        printStaIp7Seg();
        ntpAlarmCounter = 0;//???????
        ntpFetchFlag = true;
        connected = 1;
      }
    else if( ( spiffs_DISPLAY_SIZE[0] == '1' ) && ( spiffs_DISPLAY_SIZE[1] == '6' ) )
      {
        printStaIp2x2();
        ntpAlarmCounter = 0;//???????
        ntpFetchFlag = true;
        connected = 1;
      }
      else if( ( spiffs_DISPLAY_SIZE[0] == '3' ) && ( spiffs_DISPLAY_SIZE[1] == '2' ) )
      {
        printStaIp3x3();
        ntpAlarmCounter = 0;//???????
        ntpFetchFlag = true;
        connected = 1;
      }
      Serial << (F("IP address is ")) << WiFi.localIP() << endl;
  }//dhcp ip end 
  else if (spiffs_DHCP[0] == '0') 
  {
    // Set your Static IP address
    IPAddress local_IP;
    local_IP.fromString(spiffs_IP_ADDR);
    // Set your Gateway IP address
    IPAddress gateway;
    gateway.fromString(spiffs_IP_GATE);
    IPAddress subnet;
    subnet.fromString(spiffs_IP_MASK);
    IPAddress primaryDNS(8, 8, 8, 8);    //optional
    IPAddress secondaryDNS(8, 8, 4, 4);  //optional
    WiFi.config(local_IP, gateway, subnet, primaryDNS, secondaryDNS);
    WiFi.mode(WIFI_STA);
    WiFi.begin(spiffs_SSID, spiffs_PASSWORD);
    delay(2000);
    while ((WiFi.status() != WL_CONNECTED) && (retryCounter < 5)) 
    {
      delay(2000);
      retryCounter++;
    }
    if(retryCounter == 5)
    {
      showStatus(STATUS_CONNERROR);
      wm.setConfigPortalBlocking(false);
      wm.startConfigPortal(spiffs_AP_TIMEOUT);
      Serial.println("Connection error, Starting Config Portal");
      
      if( ( spiffs_DISPLAY_SIZE[0] == '4' ) && ( spiffs_DISPLAY_SIZE[1] == 'd' ) && ( spiffs_DISPLAY_SIZE[2] == '7' ) && ( spiffs_DISPLAY_SIZE[3] == 's' ) )
      {
        printApIp7Seg();

      }
      if( ( spiffs_DISPLAY_SIZE[0] == '1' ) && ( spiffs_DISPLAY_SIZE[1] == '6' ) )
      {
        printApIp2x2();
        
      }
      if( ( spiffs_DISPLAY_SIZE[0] == '3' ) && ( spiffs_DISPLAY_SIZE[1] == '2' ) )
      {
        printApIp3x3();
        
      }
      delay(2000);
    }
    else if( ( spiffs_DISPLAY_SIZE[0] == '4' ) && ( spiffs_DISPLAY_SIZE[1] == 'd' ) && ( spiffs_DISPLAY_SIZE[2] == '7' ) && ( spiffs_DISPLAY_SIZE[3] == 's' ) )
      {
        printStaIp7Seg();
        ntpAlarmCounter = 0;//???????
        ntpFetchFlag = true;
        connected = 1;
      }
      else if( ( spiffs_DISPLAY_SIZE[0] == '1' ) && ( spiffs_DISPLAY_SIZE[1] == '6' ) )
      {
        printStaIp2x2();
        ntpAlarmCounter = 0;//???????
        ntpFetchFlag = true;
        connected = 1;
      }
      else if( ( spiffs_DISPLAY_SIZE[0] == '3' ) && ( spiffs_DISPLAY_SIZE[1] == '2' ) )
      {
        printStaIp3x3();
        ntpAlarmCounter = 0;//???????
        ntpFetchFlag = true;
        connected = 1;
      }
    
    Serial << (F("IP address is ")) << WiFi.localIP() << endl;
  }//static ip end
  showStatus(STATUS_CONN_OK);
  delay(2000);
  RTC.begin();
  RTC.squareWave(DS3232RTC::SQWAVE_1_HZ);  // 1 Hz square wave

  sysClock = RTC.get();                    // synchronise the sysClock with the RTC for initial time setting
  ntpAlarmCounter = NTP_FETCH_PERIOD - 2;  // trigger an NTP fetch on first-run
  ntpClient.begin(UDP_LISTEN_PORT);
  // set up the RTC interrupt. MUST BE A VALID EXTERNAL INTERRUPT!
  // the Arduino ESP8266 IDE can support digitalPinToInterrupt()
  // but, to be safe...
  attachInterrupt(RTC_INTERRUPT_PIN, rtcIntISR, CHANGE);
  // the RTC Interrupt output is open collector so set the pullup resistor on the interrupt pin
  pinMode(RTC_INTERRUPT_PIN, INPUT_PULLUP);
  showStatus(STATUS_RUNNING);




  custom_dhcp.setValue( spiffs_DHCP,40); 
  custom_ip_addr.setValue( spiffs_IP_ADDR,40); 
  custom_ip_gate.setValue( spiffs_IP_GATE,40); 
  custom_ip_mask.setValue( spiffs_IP_MASK,40); 
  custom_ip_access.setValue( spiffs_IP_ACCESS,40); 
  custom_ap_timeout.setValue( spiffs_AP_TIMEOUT,40); 

  custom_ntp_ip.setValue( spiffs_NTP_IP,40); 
  custom_ntp_url.setValue( spiffs_NTP_URL,40); 

  custom_ntp_timezone.setValue( spiffs_NTP_TIMEZONE,40); 
  custom_ntp_gpsenable.setValue( spiffs_NTP_GPSENABLE,40); 

  custom_display_brightness_automanual.setValue( spiffs_BRIGHTNESS_AUTOMANUAL,40); 
  custom_display_brightness_val.setValue( spiffs_BRIGHTNESS_VAL,40); 
  custom_display_colon_blink.setValue( spiffs_COLON_BLINK,40); 

  custom_display_size.setValue(spiffs_DISPLAY_SIZE,40); 

  if(connected == 1)
    {
    wm.setConfigPortalTimeout(120);
    wm.setConfigPortalBlocking(false);
    wm.startConfigPortal(spiffs_AP_TIMEOUT);
    }

  wm.setConfigPortalBlocking(false);
  wm.startWebPortal();
}  // END OF setup

/********/
/* LOOP */
/********/

void loop() {

char c = GPS.read();
if (GPS.newNMEAreceived()) {
    // a tricky thing here is if we print the NMEA sentence, or data
    // we end up not listening and catching other sentences!
    // so be very wary if using OUTPUT_ALLDATA and trytng to print out data
    // Serial.println(GPS.lastNMEA()); // this also sets the newNMEAreceived()
    // flag to false
    if (!GPS.parse(GPS.lastNMEA())) // this also sets the newNMEAreceived() flag
                                    // to false
      return; // we can fail to parse a sentence in which case we should just
              // wait for another
  }


  if (shouldSaveConfig) 
  {
    saveConfig();
    shouldSaveConfig = false;
  }
  if (WiFi.status() == WL_CONNECTED && !connected) 
  {
    if( ( spiffs_DISPLAY_SIZE[0] == '4' ) && ( spiffs_DISPLAY_SIZE[1] == 'd' ) && ( spiffs_DISPLAY_SIZE[2] == '7' ) && ( spiffs_DISPLAY_SIZE[3] == 's' ) )
      {
        printStaIp7Seg();
      }
      else if( ( spiffs_DISPLAY_SIZE[0] == '1' ) && ( spiffs_DISPLAY_SIZE[1] == '6' ) )
      {
        printStaIp2x2();
      }
      else if( ( spiffs_DISPLAY_SIZE[0] == '3' ) && ( spiffs_DISPLAY_SIZE[1] == '2' ) )
      {
        printStaIp3x3();
      }
    ntpAlarmCounter = 0;//???????
    ntpFetchFlag = true;
    connected = true;

  }
  wm.process();  // do processing

  // is configuration portal requested?
  if (digitalRead(TRIGGER_PIN) == LOW && (!portalRunning)) {
    if (startAP) {
      Serial.println("Button Pressed, Starting Config Portal");


      wm.setConfigPortalBlocking(false);
      wm.startConfigPortal(spiffs_AP_TIMEOUT);
    } else {
      Serial.println("Button Pressed, Starting Web Portal");
      wm.startWebPortal();
    }
    startTime = millis();
  }
  if(spiffs_NTP_GPSENABLE[0] == '0')
  {
  // ntpAlarmCounter increments each second and sets the ntpFetchFlag
  // when the required time period has elapsed.
  if (!ntpFetchFlag && ntpAlarmCounter == NTP_FETCH_PERIOD)
  {
    ntpFetchFlag = true;  // fetch the NTP time
  } 

  //fetch the NTP time if millis haven't rolled over.
  // The valid window is millis > 2000 and millis < 4294967295 - 2000 and we also check that the NTP
  // round-trip time is acceptable. A basic retry counter attempts to fetch the NTP time a number of times
  // before giving up until the next scheduled NTP fetch time. The LED's first digit decimal point is lit
  // if the NTP fetch fails completely. On an LCD display, the first digit becomes '*'
  if (ntpFetchFlag && millis() > MILLIS_MIN && millis() < MILLIS_MAX) 
  {
    // fetch the NTP timestamp from the indexed NTP server, returns 0 if successful
    // The index allows you to choose an NTP server from the server names array easily
    uint8_t result = sendNTPrequest(0);
    if (!result && ntpRoundtrip <= NTP_ROUNDTRIP_MAX) {
      // calculate the delay before updating the RTC and sysClock
      rtcSetDelay = (uint32_t)(millis() + (1000UL - ntpFraction)) + (ntpRoundtrip >> 1);
      ntpSetFlag = true;    // sync can take place
      ntpFailFlag = false;  // clear the ntpFailFlag
      ntpAlarmCounter = 0;  // clear the ntpAlarmCounter
      ntpTime++;            // add 1 second as we're setting the sysClock 1 second late
    } else 
    {
      switch (result) 
      {
        case 1:
          Serial << F("NTP beginPacket Failure!") << endl;
          
          break;
        case 2:
          Serial << F("NTP Client endPacket Failure!") << endl;
          break;
        case 3:
          Serial << F("NTP Timeout Error!") << endl;
          break;
        case 4:
          Serial << F("NTP Packet Size Error!") << endl;
          break;
        default:
          Serial << F("NTP Round-tript too long, aborting!") << endl;
      }
      if(result >0)
      {
        showStatus(STATUS_CONNERROR);
      }
      // the NTP fetch has failed, so start counting the failures
      if (ntpFailCounter++ == NTP_FAIL_COUNT) 
      {
        // total NTP fetch failure
        ntpAlarmCounter = 0;  // reset the ntpAlarmCounter
        ntpFailCounter = 0;   // reset the ntpFailCounter
        ntpFailFlag = true;   // set the ntpFailFlag
        Serial << F("Total NTP Fetch Failure!") << endl;
      } else ntpAlarmCounter -= NTP_FAIL_RETRY;  // try an NTP fetch again in NTP_FAIL_RETRY seconds
    }
    ntpFetchFlag = false;  // clear the fetch Alarm flag
  }
  // sync everything when rtcSetDelay has expired
  if (ntpSetFlag && millis() >= rtcSetDelay) 
  {
    RTC.set(ntpTime);    // set the RTC
    sysClock = ntpTime;  // set sysClock
    ntpSetFlag = false;  // clear the sync flag
    timeSynced = true;   // time DEBUG printout includes NTP timing details
    rtcSetDelay = 0;
  }
  }
if(spiffs_NTP_GPSENABLE[0] == '1')
  {

    
    if (gpsFetchFlag) 
    {
    time_t gpsTimet;
    tmElements_t gps_time;
    
    gps_time.Year = GPS.year;
    gps_time.Month = GPS.month;
    gps_time.Day = GPS.day;
    gps_time.Hour = GPS.hour;
    gps_time.Minute = GPS.minute;
    gps_time.Second = GPS.seconds;
    gpsTimet = makeTime(gps_time);

    if((int)GPS.fix)
    {
      RTC.set(gpsTimet);    // set the RTC
    sysClock = gpsTimet;  // set sysClock
    }
    
    Serial.print("\nDate: ");
    Serial.print(gps_time.Year, DEC);
    Serial.print("-");
    Serial.print(gps_time.Month, DEC);
    Serial.print("-");
    Serial.print(gps_time.Day, DEC);
    Serial.print("   Time: ");
    Serial.print(gps_time.Hour, DEC);
    Serial.print(':');
    Serial.print(gps_time.Minute, DEC);
    Serial.print(':');
    Serial.println(gps_time.Second, DEC);
    Serial.print("Fix: ");
    Serial.print((int)GPS.fix);
    Serial.print(" quality: ");
    Serial.println((int)GPS.fixquality);
    Serial.print("Time [s] since last fix: ");
    Serial.println(GPS.secondsSinceFix(), 3);
    Serial.print("    since last GPS time: ");
    Serial.println(GPS.secondsSinceTime(), 3);
    Serial.print("    since last GPS date: ");
    Serial.println(GPS.secondsSinceDate(), 3);
    Serial.print("Satellites: ");
    Serial.println((int)GPS.satellites);
    gpsFetchFlag = false;
    }

  }
  

  // print out the sysClock timestamp
  if (outputTimestampEnable) 
  {
    outputTimestampEnable = false;  // clear the trigger flag
    char buff[32];
    tmElements_t tm;
    // make the current local time using the Timezone library
    if ((spiffs_NTP_TIMEZONE[0] == 'C') && (spiffs_NTP_TIMEZONE[1] == 'E') && (spiffs_NTP_TIMEZONE[2] == NULL)) 
    {
      breakTime(CE.toLocal(sysClock, &tcr), tm);
    } else if ((spiffs_NTP_TIMEZONE[0] == 'C') && (spiffs_NTP_TIMEZONE[1] == 'E') && (spiffs_NTP_TIMEZONE[2] == 'T') && (spiffs_NTP_TIMEZONE[3] == NULL)) 
    {
      breakTime(CEt.toLocal(sysClock, &tcr), tm);
    } else if ((spiffs_NTP_TIMEZONE[0] == 'C') && (spiffs_NTP_TIMEZONE[1] == 'E') && (spiffs_NTP_TIMEZONE[2] == 'S') && (spiffs_NTP_TIMEZONE[3] == 'T') && (spiffs_NTP_TIMEZONE[4] == NULL)) 
    {
      breakTime(CEst.toLocal(sysClock, &tcr), tm);
    }
    sprintf(buff, "%02u:%02u:%02u %s  %02u-%s-20%02u", tm.Hour, tm.Minute, tm.Second, weekdays[tm.Wday], tm.Day, months[tm.Month], tm.Year - 30);
    int num;
    num = tm.Minute*100;
    num+= tm.Second;
    int analogVal = map(analogRead(8),0,4096,30,255);
    if(spiffs_BRIGHTNESS_AUTOMANUAL[0] == '1')
    {
      String brightnessval = String(spiffs_BRIGHTNESS_VAL);
      setBrightness(brightnessval.toInt());
    }
    if(spiffs_BRIGHTNESS_AUTOMANUAL[0] == '0')
    {
    
    setBrightness(map(analogVal,255,30,10,100));
    }
    if( ( spiffs_NTP_IP[0] == '0' ) && ( spiffs_NTP_IP[1] == 0 ))
    {
      ntpShouldUseIp = 0;
      ntpServer = spiffs_NTP_URL;
    }
    else if( isIp ( String ( spiffs_NTP_IP ) ) )
    {
      ntpServerIp.fromString(spiffs_NTP_IP);
      ntpShouldUseIp = 1;
    }
    
    display.showNumberDecEx(analogVal,0,false,4,0);
    if(halfSec)
    {
        wm.setConfigPortalBlocking(false);
        wm.startWebPortal();
      memset(displayData, 0x00, 144 * 2);
      if(spiffs_COLON_BLINK[0] == '1')
      {
        if( ( spiffs_DISPLAY_SIZE[0] == '4' ) && ( spiffs_DISPLAY_SIZE[1] == 'd' ) && ( spiffs_DISPLAY_SIZE[2] == '7' ) && ( spiffs_DISPLAY_SIZE[3] == 's' ) )
        {
          writeChar7Seg((tm.Hour/10)+0x30, 0);
          writeChar7Seg((tm.Hour%10)+0x30, 1);
          writeChar7Seg((tm.Minute/10)+0x30, 2);
          writeChar7Seg((tm.Minute%10)+0x30, 3);
          writeChar7Seg(20+0x30, 4);
        }
        if( ( spiffs_DISPLAY_SIZE[0] == '1' ) && ( spiffs_DISPLAY_SIZE[1] == '6' ) )
        {
          WriteBigChar((tm.Hour/10)+0x30,0,0,1);
          WriteBigChar((tm.Hour%10)+0x30,16,0,1);
          drawPixel(31, 11, 1);
          drawPixel(31, 10, 1);
          drawPixel(32, 11, 1);
          drawPixel(32, 10, 1);
          drawPixel(31, 5, 1);
          drawPixel(31, 4, 1);
          drawPixel(32, 5, 1);
          drawPixel(32, 4, 1);
          WriteBigChar((tm.Minute/10)+0x30,35,0,1);
          WriteBigChar((tm.Minute%10)+0x30,51,0,1);
          sendDisplay16();
        }
        if( ( spiffs_DISPLAY_SIZE[0] == '3' ) && ( spiffs_DISPLAY_SIZE[1] == '2' ) )
        {
          WriteBiggerChar((tm.Hour/10)+0x30,0,0,1);
          WriteBiggerChar((tm.Hour%10)+0x30,23,0,1);
          for(int y = 15; y <18;y++)
          {
            for(int x = 45; x<51;x++)
            {
              drawPixel(x, y, 1);
            }
          }
          for(int y = 6; y <9;y++)
          {
            for(int x = 45; x<51;x++)
            {
              drawPixel(x, y, 1);
            }
          }
          WriteBiggerChar((tm.Minute/10)+0x30,55,0,1);
          WriteBiggerChar((tm.Minute%10)+0x30,78,0,1);
          sendDisplay();
        }
      }
      else
      {
        if( ( spiffs_DISPLAY_SIZE[0] == '4' ) && ( spiffs_DISPLAY_SIZE[1] == 'd' ) && ( spiffs_DISPLAY_SIZE[2] == '7' ) && ( spiffs_DISPLAY_SIZE[3] == 's' ) )
        {
          writeChar7Seg((tm.Hour/10)+0x30, 0);
          writeChar7Seg((tm.Hour%10)+0x30, 1);
          writeChar7Seg((tm.Minute/10)+0x30, 2);
          writeChar7Seg((tm.Minute%10)+0x30, 3);
          writeChar7Seg(20+0x30, 4);
        }
        if( ( spiffs_DISPLAY_SIZE[0] == '1' ) && ( spiffs_DISPLAY_SIZE[1] == '6' ) )
        {
          WriteBigChar((tm.Hour/10)+0x30,0,0,1);
          WriteBigChar((tm.Hour%10)+0x30,16,0,1);
          drawPixel(31, 11, 1);
          drawPixel(31, 10, 1);
          drawPixel(32, 11, 1);
          drawPixel(32, 10, 1);
          drawPixel(31, 5, 1);
          drawPixel(31, 4, 1);
          drawPixel(32, 5, 1);
          drawPixel(32, 4, 1);
          WriteBigChar((tm.Minute/10)+0x30,35,0,1);
          WriteBigChar((tm.Minute%10)+0x30,51,0,1);
          sendDisplay16();
        }
        if( ( spiffs_DISPLAY_SIZE[0] == '3' ) && ( spiffs_DISPLAY_SIZE[1] == '2' ) )
        {
          WriteBiggerChar((tm.Hour/10)+0x30,0,0,1);
          WriteBiggerChar((tm.Hour%10)+0x30,23,0,1);
          for(int y = 15; y <18;y++)
          {
            for(int x = 45; x<51;x++)
            {
              drawPixel(x, y, 1);
            }
          }
          for(int y = 6; y <9;y++)
          {
            for(int x = 45; x<51;x++)
            {
              drawPixel(x, y, 1);
            }
          }
          WriteBiggerChar((tm.Minute/10)+0x30,55,0,1);
          WriteBiggerChar((tm.Minute%10)+0x30,78,0,1);
          sendDisplay();
        }
      }

      

      // WriteChar((tm.Hour/10)+0x30,0,0, 1);
      // WriteChar((tm.Hour%10)+0x30,7,0, 1);
      // WriteChar(':',14,0, 1);
      // WriteChar((tm.Minute/10)+0x30,21,0, 1);
      // WriteChar((tm.Minute%10)+0x30,28,0, 1);
      // WriteChar(':',35,0, 1);
      // WriteChar((tm.Second/10)+0x30,42,0, 1);
      // WriteChar((tm.Second%10)+0x30,49,0, 1);
      /*WriteBiggerChar((tm.Minute/10)+0x30,0,0,1);
      WriteBiggerChar((tm.Minute%10)+0x30,16,0,1);
      drawPixel(31, 11, 1);
      drawPixel(31, 10, 1);
      drawPixel(32, 11, 1);
      drawPixel(32, 10, 1);

      drawPixel(31, 5, 1);
      drawPixel(31, 4, 1);
      drawPixel(32, 5, 1);
      drawPixel(32, 4, 1);
      WriteBiggerChar((tm.Second/10)+0x30,35,0,1);
      WriteBiggerChar((tm.Second%10)+0x30,51,0,1);
      //2x2 display
      */
      // WriteBiggerChar((tm.Minute/10)+0x30,0,0,1);
      // WriteBiggerChar((tm.Minute%10)+0x30,23,0,1);
      // for(int y = 15; y <18;y++)
      //  {
      //   for(int x = 45; x<51;x++)
      //   {
      //     drawPixel(x, y, 1);
      //   }
      //  }
      //  for(int y = 6; y <9;y++)
      //  {
      //   for(int x = 45; x<51;x++)
      //   {
      //     drawPixel(x, y, 1);
      //   }
      //  }
      // WriteBiggerChar((tm.Second/10)+0x30,55,0,1);
      // WriteBiggerChar((tm.Second%10)+0x30,78,0,1);
        //3*3 display
       





      // uint32_t temp = 0x24242424;
      // uint32_t temp2 = 0x24242424;
      // for(int i = 0;i<32;i++)
      // {
      //   if( ( temp >> i ) & 1 )
      //   {
      //     drawPixel(i,0,1);
      //   }

      // }
      // for(int i = 32;i<64;i++)
      // {
      //   if( ( temp2 >> i ) & 1 )
      //   {
      //     drawPixel(i,0,1);
      //   }

      // }
      //sendDisplay();
      
    }
    else
    {
     //display.showNumberDecEx(num,0b01000000,false,4,0);

      // WriteChar((tm.Hour/10)+0x30,0,0, 1);
      // WriteChar((tm.Hour%10)+0x30,7,0, 1);
      // WriteChar(':',14,0, 1);
      // WriteChar((tm.Minute/10)+0x30,21,0, 1);
      // WriteChar((tm.Minute%10)+0x30,28,0, 1);
      // WriteChar(':',35,0, 1);
      // WriteChar((tm.Second/10)+0x30,42,0, 1);
      // WriteChar((tm.Second%10)+0x30,49,0, 1);

      /*WriteBiggerChar((tm.Minute/10)+0x30,0,0,1);
      WriteBiggerChar((tm.Minute%10)+0x30,16,0,1);
      drawPixel(31, 11, 1);
      drawPixel(31, 10, 1);
      drawPixel(32, 11, 1);
      drawPixel(32, 10, 1);

      drawPixel(31, 5, 1);
      drawPixel(31, 4, 1);
      drawPixel(32, 5, 1);
      drawPixel(32, 4, 1);
      WriteBiggerChar((tm.Second/10)+0x30,35,0,1);
      WriteBiggerChar((tm.Second%10)+0x30,51,0,1);
      //2x2 display
      */
      // WriteBiggerChar((tm.Minute/10)+0x30,0,0,1);
      // WriteBiggerChar((tm.Minute%10)+0x30,23,0,1);


      // WriteBiggerChar((tm.Second/10)+0x30,55,0,1);
      // WriteBiggerChar((tm.Second%10)+0x30,78,0,1);
      //3x3 display


      memset(displayData, 0x00, 144 * 2);
      if(spiffs_COLON_BLINK[0] == '1')
      {
        if( ( spiffs_DISPLAY_SIZE[0] == '4' ) && ( spiffs_DISPLAY_SIZE[1] == 'd' ) && ( spiffs_DISPLAY_SIZE[2] == '7' ) && ( spiffs_DISPLAY_SIZE[3] == 's' ) )
        {
          writeChar7Seg((tm.Hour/10)+0x30, 0);
          writeChar7Seg((tm.Hour%10)+0x30, 1);
          writeChar7Seg((tm.Minute/10)+0x30, 2);
          writeChar7Seg((tm.Minute%10)+0x30, 3);
          writeChar7Seg(17+0x30, 4);
        }
        if( ( spiffs_DISPLAY_SIZE[0] == '1' ) && ( spiffs_DISPLAY_SIZE[1] == '6' ) )
        {
          WriteBigChar((tm.Hour/10)+0x30,0,0,1);
          WriteBigChar((tm.Hour%10)+0x30,16,0,1);
          drawPixel(31, 11, 0);
          drawPixel(31, 10, 0);
          drawPixel(32, 11, 0);
          drawPixel(32, 10, 0);
          drawPixel(31, 5, 0);
          drawPixel(31, 4, 0);
          drawPixel(32, 5, 0);
          drawPixel(32, 4, 0);
          WriteBigChar((tm.Minute/10)+0x30,35,0,1);
          WriteBigChar((tm.Minute%10)+0x30,51,0,1);
          sendDisplay16();
        }
        if( ( spiffs_DISPLAY_SIZE[0] == '3' ) && ( spiffs_DISPLAY_SIZE[1] == '2' ) )
        {
          WriteBiggerChar((tm.Hour/10)+0x30,0,0,1);
          WriteBiggerChar((tm.Hour%10)+0x30,23,0,1);
          for(int y = 15; y <18;y++)
          {
            for(int x = 45; x<51;x++)
            {
              drawPixel(x, y, 0);
            }
          }
          for(int y = 6; y <9;y++)
          {
            for(int x = 45; x<51;x++)
            {
              drawPixel(x, y, 0);
            }
          }
          WriteBiggerChar((tm.Minute/10)+0x30,55,0,1);
          WriteBiggerChar((tm.Minute%10)+0x30,78,0,1);
          sendDisplay();
        }
      }
      else
      {
        if( ( spiffs_DISPLAY_SIZE[0] == '4' ) && ( spiffs_DISPLAY_SIZE[1] == 'd' ) && ( spiffs_DISPLAY_SIZE[2] == '7' ) && ( spiffs_DISPLAY_SIZE[3] == 's' ) )
        {
          writeChar7Seg((tm.Hour/10)+0x30, 0);
          writeChar7Seg((tm.Hour%10)+0x30, 1);
          writeChar7Seg((tm.Minute/10)+0x30, 2);
          writeChar7Seg((tm.Minute%10)+0x30, 3);
          writeChar7Seg(20+0x30, 4);
        }
        if( ( spiffs_DISPLAY_SIZE[0] == '1' ) && ( spiffs_DISPLAY_SIZE[1] == '6' ) )
        {
          WriteBigChar((tm.Hour/10)+0x30,0,0,1);
          WriteBigChar((tm.Hour%10)+0x30,16,0,1);
          drawPixel(31, 11, 1);
          drawPixel(31, 10, 1);
          drawPixel(32, 11, 1);
          drawPixel(32, 10, 1);
          drawPixel(31, 5, 1);
          drawPixel(31, 4, 1);
          drawPixel(32, 5, 1);
          drawPixel(32, 4, 1);
          WriteBigChar((tm.Minute/10)+0x30,35,0,1);
          WriteBigChar((tm.Minute%10)+0x30,51,0,1);
          sendDisplay16();
        }
        if( ( spiffs_DISPLAY_SIZE[0] == '3' ) && ( spiffs_DISPLAY_SIZE[1] == '2' ) )
        {
          WriteBiggerChar((tm.Hour/10)+0x30,0,0,1);
          WriteBiggerChar((tm.Hour%10)+0x30,23,0,1);
          for(int y = 15; y <18;y++)
          {
            for(int x = 45; x<51;x++)
            {
              drawPixel(x, y, 1);
            }
          }
          for(int y = 6; y <9;y++)
          {
            for(int x = 45; x<51;x++)
            {
              drawPixel(x, y, 1);
            }
          }
          WriteBiggerChar((tm.Minute/10)+0x30,55,0,1);
          WriteBiggerChar((tm.Minute%10)+0x30,78,0,1);
          sendDisplay();
        }
      }

      // uint32_t temp = 0x24242424;
      // uint32_t temp2 = 0x24242424;
      // for(int i = 0;i<32;i++)
      // {
      //   if( ( temp >> i ) & 1 )
      //   {
      //     drawPixel(i,0,1);
      //   }

      // }
      // for(int i = 32;i<64;i++)
      // {
      //   if( ( temp2 >> i ) & 1 )
      //   {
      //     drawPixel(i,0,1);
      //   }

      // }
      //sendDisplay();
      
    }


    Serial.println(buff);

    timeSynced = false;
  }
}  // END OF loop
